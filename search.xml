<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac os thrift旧版本安装爬坑指南</title>
    <url>/2019/06/01/MacOS%20thrift%E6%97%A7%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h5 id="Mac-os-thrift旧版本安装爬坑指南"><a href="#Mac-os-thrift旧版本安装爬坑指南" class="headerlink" title="Mac os thrift旧版本安装爬坑指南"></a>Mac os thrift旧版本安装爬坑指南</h5><p>喜欢使用brew来进行一键安装:</p>
<blockquote>
<p><a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">homebrew官网</a><br><a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener">homebrew-core github网址</a></p>
</blockquote>
<ul>
<li><p>对于安装最新新版本thrift,我们可以直接是用brew install thrift     </p>
</li>
<li><p>使用brew search thrift;查看不同版本的thrift。然后brew install <a href="mailto:thrift@0.9.0" target="_blank" rel="noopener">thrift@0.9.0</a></p>
</li>
<li><p>使用复杂brew方案进行安装。思路同时通过找到旧版本的thrift.rb。</p>
<ol>
<li>将homebrew-core的git文件下载到本地。</li>
<li>通过查看Formula/thrift.rb的history。   </li>
</ol>
<a id="more"></a> 
<p><code>git log 234b34ab1418bd42b14e73dbeea179f40ef1bec2 -- Formula/thrift.rb</code></p>
<ol start="3">
<li><p>找到旧版本的commit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  commit 9d524e4850651cfedd64bc0740f1379b533f607d</span><br><span class="line">Author: BrewTestBot &lt;brew-test-bot@googlegroups.com&gt;</span><br><span class="line">Date:   Thu Dec 29 18:54:26 2016 +0000</span><br><span class="line"></span><br><span class="line">    thrift: update 0.9.3 bottle.</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后将链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/Homebrew/homebrew-core/blob/&#123;commit_id&#125;/Formula/thrift.rb</span><br><span class="line">即:</span><br><span class="line">https://github.com/Homebrew/homebrew-core/blob/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb</span><br></pre></td></tr></table></figure>
</li>
<li><p>点击页面上按钮“Raw”,获取文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://raw.githubusercontent.com/Homebrew/homebrew-core/&#123;commit_id&#125;/Formula/thrift.rb</span><br><span class="line">即:</span><br><span class="line">https://raw.githubusercontent.com/Homebrew/homebrew-core/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb</span><br></pre></td></tr></table></figure>
</li>
<li><p>在命令行上 brew install <a href="https://raw.githubusercontent.com/Homebrew/homebrew-core/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/homebrew-core/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb</a><br>即可。<br>安装成功。</p>
</li>
</ol>
<p>参考网址:<br><a href="https://apple.stackexchange.com/questions/352477/install-older-removed-brew-formula-version" target="_blank" rel="noopener">Install older removed brew formula version</a></p>
</li>
</ul>
<h5 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h5><blockquote>
<p><a href="https://thrift.apache.org/" target="_blank" rel="noopener">thrift快速指南</a></p>
</blockquote>
<ul>
<li><a href="https://github.com/apache/thrift/releases" target="_blank" rel="noopener">下载旧版本</a></li>
<li><a href="https://thrift.apache.org/docs/install/" target="_blank" rel="noopener">安装下载thrift要求的其他工具|插件</a></li>
<li><a href="https://thrift.apache.org/docs/BuildingFromSource" target="_blank" rel="noopener">配置、编译、安装</a></li>
</ul>
<hr>
<h5 id="开始爬坑"><a href="#开始爬坑" class="headerlink" title="开始爬坑"></a>开始爬坑</h5><ul>
<li><p>安装前要求工具 可以使用brew install 进行安装</p>
<blockquote>
<p><a href="https://thrift.apache.org/docs/install/os_x" target="_blank" rel="noopener">https://thrift.apache.org/docs/install/os_x</a><br>boost<br>libevent<br>openssl<br>bison 2.5  </p>
</blockquote>
</li>
<li><p>下载thrift文件安装包</p>
<blockquote>
<p><a href="https://github.com/apache/thrift/releases/tag/0.9.3" target="_blank" rel="noopener">https://github.com/apache/thrift/releases/tag/0.9.3</a><br>tar -zxvf 解压</p>
</blockquote>
</li>
<li><p>编译流程</p>
<blockquote>
<p>./configure –prefix=/usr/local/ –disable-static –without-python –without-csharp –without-ruby –without-perl –without-php –without-haskell –without-erlang<br><a href="https://thrift.apache.org/docs/BuildingFromSource" target="_blank" rel="noopener">https://thrift.apache.org/docs/BuildingFromSource</a><br>出现bison版本低:  <a href="https://stackoverflow.com/questions/31805431/how-to-install-bison-on-mac-osx" target="_blank" rel="noopener">https://stackoverflow.com/questions/31805431/how-to-install-bison-on-mac-osx</a><br>注意需要source  .base_profile</p>
</blockquote>
</li>
<li><p>出现问题：</p>
<blockquote>
<p>src/thrift/transport/TSSLSocket.cpp:33:10: fatal error: ‘openssl/err.h’ file not found  #include &lt;openssl/err.h&gt;<br><a href="https://www.jianshu.com/p/f7380139afdd" target="_blank" rel="noopener">https://www.jianshu.com/p/f7380139afdd</a></p>
</blockquote>
</li>
</ul>
<p>推荐阅读:<br><a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">编译器的工作过程</a></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>通过nginx控制http转https</title>
    <url>/2019/06/01/nginx%E6%8E%A7%E5%88%B6http%E8%BD%AChttps/</url>
    <content><![CDATA[<h5 id="通过nginx控制http转https"><a href="#通过nginx控制http转https" class="headerlink" title="通过nginx控制http转https"></a>通过nginx控制http转https</h5><blockquote>
<p>现在越来越多的公司选择https的协议。<br>我司的做法: nginx上进行https的认证，在请求在交给tomcat进行处理。而tomcat处理的是http的请求。因为当进行tomcat应用程进行重定向时直接使用http的请求在处理。</p>
</blockquote>
<p>为了保证整个请求都是https请求。我们需要将返回的请求进行重定向为https的。</p>
<p>通过proxy-redirect修改Location中的url。</p>
<ol>
<li>将 conf/conf.d/proxy_params文件中 <code>proxy_redirect off;</code> 注释掉</li>
<li>将<br>proxy_redirect <a href="http://www.xxxxx.com/" target="_blank" rel="noopener">http://www.xxxxx.com/</a> <a href="https://www.xxxxx.com/" target="_blank" rel="noopener">https://www.xxxxx.com/</a>;<br>proxy_redirect <a href="http://xxxxx.com/" target="_blank" rel="noopener">http://xxxxx.com/</a> <a href="https://xxxx.com/" target="_blank" rel="noopener">https://xxxx.com/</a>;<br>放入到server {}块中。</li>
</ol>
<p>如果一直使用http的协议，容易出现网页中有代码注入广告的现象。运营商就经常将小广告注入到网页中，一般是网页的右下角有个摆动的小图标。使用https的协议，能够降低这一现象。不过一山更比一山高，https的也会有网页代码注入的现象，不过特别隐蔽。我遇到表现是打开应用的中网页时会启动其他应用程序如京东、淘宝。<a href="https://www.zhihu.com/question/35720092/answer/523563873" target="_blank" rel="noopener">对这一现象的说明和解决方案</a></p>
<p>参考资料:<br><a href="http://info.siven.net/posts/d925bb5d.html" target="_blank" rel="noopener">Nginx SSL 结合Tomcat 重定向URL变成HTTP的问题</a></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP大文件上传思路和总结</title>
    <url>/2019/06/01/HTTP%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h5 id="HTTP大文件上传思路和总结"><a href="#HTTP大文件上传思路和总结" class="headerlink" title="HTTP大文件上传思路和总结"></a>HTTP大文件上传思路和总结</h5><h5 id="无法http大文件一次性上传的原因"><a href="#无法http大文件一次性上传的原因" class="headerlink" title="无法http大文件一次性上传的原因"></a>无法http大文件一次性上传的原因</h5><blockquote>
<p>存在文件上传大小的限制</p>
</blockquote>
<ol>
<li>默认一般nginx和tomcat都会对上传文件大小进行限制<br>nginx的配置文件nginx.conf设置 client_max_body_size    20m;   </li>
<li>tomcat默认设置能接收HTTP POST请求的大小最大为2M。如果POST请求传递的数据大于2M,就会报错误。解决方案：修改tomcat的配置server.xml中<connector>标签,在该标签中添 加”maxPostSize”属性,将该属性值设置成你想要的最大值,单位是字节,或者把这个值设置为 0(maxPostSize=”0”)。    </connector></li>
<li><a href="https://www.jianshu.com/p/285ad45f60d1" target="_blank" rel="noopener">Tomcat项目的web配置</a>。工程项目web.xml的配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;multipart-config&gt;</span><br><span class="line">&lt;location&gt;&lt;/location&gt;</span><br><span class="line">&lt;max-file-size&gt;&lt;/max-file-size&gt;</span><br><span class="line">&lt;max-request-size&gt;&lt;/max-request-size&gt;</span><br><span class="line">&lt;file-size-threshold&gt;&lt;/file-size-threshold&gt;</span><br><span class="line">&lt;/multipart-config&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li>Spring配置文件限制上传文件的大小    </li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;multipartResolver&quot;</span><br><span class="line">        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;maxUploadSize&quot; value=&quot;41943040&quot; /&gt; &lt;!-- 40mb --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p>错误方案1:<br>1、分片上传大文件<br>2、服务端将每片文件存成临时文件，然后在进行合并文件。<br><strong>存在无核实合并文件是否正确的问题</strong></p>
<p>错误方案2:<br><img src="/images/Http%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B.jpg" alt="http分片上传方案"><br>md5文件摘要，确保合并文件没有问题。<br><strong>存在重复造轮子问题。在分布式服务器中进行分片上传无法控制同一个服务器上</strong></p>
<p>前端选择<a href="http://fex-team.github.io/webuploader/" target="_blank" rel="noopener">WebUploader</a>进行上传。<br>后端没有选择控制nginx路由到指定服务器，而是选择单点文件上传服务thrift。</p>
<blockquote>
<p>单点文件上传服务thrift提供功能</p>
</blockquote>
<ol>
<li>存储分片文件和合并分片文件进行存储</li>
<li>获取文件上传的状态</li>
</ol>
<p>前后端交互流程：</p>
<ul>
<li>前端向服务器获取上传文件的唯一标识。（可以写入数据库获取id标识）</li>
<li>前端将指定文件md5，分片上传 {file,chunk,chunks,md5value,唯一id标识, 额外自定义字段}</li>
<li>服务端检查是否存在唯一id标识，校验参数正确性  <ol>
<li>调用单点文件上传服务，存储指定文件路径夹下（使用 <code>md5Value+userId+唯一id标识</code> 作为唯一文件夹名称）</li>
<li>单点文件上传服务通过对分片文件进行排序统计返回是否可以进行合并文件操作。 | 单点文件上传服务通过对分片文件进行排序统计返回是否正在进行合并操作。</li>
</ol>
</li>
<li>前端收到合并信息停止上传文片文件并调用服务端进行文件合并。</li>
<li>服务端清理相关的文件夹。</li>
<li>当前端接收上传失败的信息，需要调用服务端清理相关文件的操作。</li>
</ul>
<hr>
<h6 id="安卓APK文件上传（不是特别规范，有待以后自己多加研究）"><a href="#安卓APK文件上传（不是特别规范，有待以后自己多加研究）" class="headerlink" title="安卓APK文件上传（不是特别规范，有待以后自己多加研究）"></a>安卓APK文件上传（不是特别规范，有待以后自己多加研究）</h6><blockquote>
<p>前端分片文件 -&gt; 服务端 -&gt; 单点文件服务</p>
</blockquote>
<ul>
<li>单点文件服务是否在合并文件 -&gt; 服务端 -&gt; 前端</li>
</ul>
<p><strong>这一步就是为了让服务端分片不去占用磁盘。降低出错下，产生大量临时文件</strong></p>
<blockquote>
<p>前端删除分片文件 -&gt; 服务端 -&gt; 单点文件服务      </p>
</blockquote>
<ul>
<li>单点文件服务删除分片文件 -&gt; 服务端 -&gt; 前端</li>
</ul>
<p><strong>增加这一步的原因：APK远程上传到CDN上耗时较长，容易超过request时间。改用轮询来处理，让界面不卡死，容易有反馈。</strong></p>
<blockquote>
<p>前端获取APK文件上传状态 -&gt; 服务端 -&gt; 单点文件服务</p>
</blockquote>
<ul>
<li>单点文件服务APK上传状态 -&gt; 服务端 -&gt; 前端</li>
</ul>
<p><img src="/images/APK%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.jpg" alt="APK上传流程"></p>
<p>推荐了解网址:<br><a href="https://my.oschina.net/appnet/blog/1591830" target="_blank" rel="noopener">大文件分步式分片上传和续传</a><br><a href="https://blog.kazaff.me/2014/11/14/%E8%81%8A%E8%81%8A%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener">聊聊大文件上传</a><br><a href="https://blog.breezelin.cn/scheme-nginx-php-js-upload-process.html" target="_blank" rel="noopener">HTTP文件上传的一个后端完善方案（NginX）</a><br><a href="https://segmafrontend.github.io/2018/09/19/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">大文件上传解决方案</a></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA小技巧</title>
    <url>/2019/02/12/IDEA%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><strong>* 提供IDEA使用小技巧 *</strong></p>
<blockquote>
<p>推荐一些本人亲身尝试，在实际开发中比较实用的小技巧，可以大大提高开发效率。</p>
</blockquote>
<h5 id="IDEA左侧显示打开代码文件和资源文件"><a href="#IDEA左侧显示打开代码文件和资源文件" class="headerlink" title="IDEA左侧显示打开代码文件和资源文件"></a>IDEA左侧显示打开代码文件和资源文件</h5><blockquote>
<p>应用场景:默认IDEA的代码文件的Tab放在代码区的上方。但是实际开发，我们经常打开很多代码文件，左侧显示整体显示，可以提高管理打开代码文件。</p>
</blockquote>
<h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p><img src="/images/IDEA%E5%B7%A6%E4%BE%A7%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E6%88%AA%E5%9B%BE.jpeg" alt="IDEA左侧显示打开代码文件截图"></p>
<a id="more"></a>
<h6 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤:"></a>操作步骤:</h6><p><img src="/images/IDEA%E5%B7%A6%E4%BE%A7%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%88%AA%E5%9B%BE.jpeg" alt="IDEA左侧显示打开代码文件操作截图"></p>
<h5 id="IDEA多个模块同名分支统一切换-（Multi-root-same-name-brances-change）"><a href="#IDEA多个模块同名分支统一切换-（Multi-root-same-name-brances-change）" class="headerlink" title="IDEA多个模块同名分支统一切换 （Multi-root same name brances change）"></a>IDEA多个模块同名分支统一切换 （Multi-root same name brances change）</h5><blockquote>
<p>应用场景:默认IDEA的分支操作:模块分支统一操作(Common Local Branches)和单模块分支操作(Local Branches)。 对于某个模块同名的分支的处理很难处理。 (类似问题:<a href="https://stackoverflow.com/questions/13797331/intellij-switching-between-multiple-git-local-branches" target="_blank" rel="noopener">https://stackoverflow.com/questions/13797331/intellij-switching-between-multiple-git-local-branches</a>)</p>
</blockquote>
<p>灵感来自这篇文章:<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000135790-Task-Management-does-not-respect-Execute-branch-operations-on-all-roots-setting" target="_blank" rel="noopener">Task Management does not respect “Execute branch operations on all roots” setting</a></p>
<h6 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h6><p>Click “Tools” &gt; “Tasks &amp; Contexts” &gt; “Open Task”</p>
<p><img src="/images/IDEA%E5%BC%80%E5%90%AF%E6%89%80%E6%9C%89%E6%A0%B9%E4%B8%8A%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C.jpeg" alt="IDEA开启所有根上分支操作"></p>
<p><img src="/images/IDEATask%E7%9A%84%E4%BD%8D%E7%BD%AE.jpeg" alt="IDEATask的位置"></p>
<p><img src="/images/IDEA%E7%9A%84Task%E6%93%8D%E4%BD%9C.jpeg" alt="IDEA的Task操作"></p>
<h5 id="IDEA的编辑区不换行操作"><a href="#IDEA的编辑区不换行操作" class="headerlink" title="IDEA的编辑区不换行操作"></a>IDEA的编辑区不换行操作</h5><p><img src="/images/IDEA%E4%B8%8D%E6%8D%A2%E8%A1%8C%E6%93%8D%E4%BD%9C.jpg" alt="IDEA不换行操作"></p>
<h5 id="IDEA的Commit-Changes显示提交的分支操作"><a href="#IDEA的Commit-Changes显示提交的分支操作" class="headerlink" title="IDEA的Commit Changes显示提交的分支操作"></a>IDEA的Commit Changes显示提交的分支操作</h5><p><img src="/images/IDEA%E6%8F%90%E4%BA%A4%E5%8F%98%E5%8C%96%E6%98%BE%E7%A4%BA%E5%88%86%E6%94%AF%E5%90%8D.jpg" alt="IDEA提交改变显示分支名"></p>
<h5 id="IDEA的翻译插件"><a href="#IDEA的翻译插件" class="headerlink" title="IDEA的翻译插件"></a>IDEA的翻译插件</h5><p>第一步安装插件：<br>![Translation 插件下载](/images/Translation 插件下载.jpg)<br>第二步完毕后显示位置<br>![Translation 插件显示位置](/images/Translation 插件显示位置.jpg)<br>第三步设置插件选项<br>![Translation 插件设置](/images/Translation 插件设置.jpg)</p>
]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOX安装JMagick</title>
    <url>/2019/01/29/MacOX%E5%AE%89%E8%A3%85JMagick/</url>
    <content><![CDATA[<h5 id="MacOX安装JMgick原因和使用JMagick执行流程"><a href="#MacOX安装JMgick原因和使用JMagick执行流程" class="headerlink" title="MacOX安装JMgick原因和使用JMagick执行流程"></a>MacOX安装JMgick原因和使用JMagick执行流程</h5><blockquote>
<p>目前对于图片处理，很少采用java去处理图片，性能不是很好。目前我们公司采用ImageMagick图片处理，有些采用Process执行cmd命令，有些采用jmagick的java接口进行处理。</p>
</blockquote>
<p><a href="https://www.imagemagick.org/index.php" target="_blank" rel="noopener">ImageMagick官网</a><br>通过jmagick调用native方法来调用JMagick的方法, 再由JMagick调用ImageMagick的方法。jmagick使用Java代码写的。JMagick使用C语言写的，含有java JNI生成的头文件。ImageMagick使用C语言写的，没有含有java JNI生成的头文件。 <a href="https://elf8848.iteye.com/blog/455675" target="_blank" rel="noopener">ImageMagick介绍和执行流程原因解释</a>         </p>
<ul>
<li>执行流程:                     </li>
<li>jmagick（java） –&gt; JMagick(C) –&gt; ImageMagick(C)</li>
</ul>
<a id="more"></a>
<h5 id="本地MacOX执行遇到问题"><a href="#本地MacOX执行遇到问题" class="headerlink" title="本地MacOX执行遇到问题"></a>本地MacOX执行遇到问题</h5><p>new MagickInfo(“”); 调用时出现无法加载MagickLoader，实际无法加载资源JMagick；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(&quot;magick.MagickLoader&quot;).newInstance();</span><br><span class="line">public class MagickLoader &#123;</span><br><span class="line">    static &#123;      </span><br><span class="line">        System.loadLibrary(&quot;JMagick&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为jmagick的接口都是本地调用，需要加载JNI的JMagick动态库。因此，接下来我们的主要任务是生成JMagick的动态库。<br>通过Brew install ImageMagick直接安装使用。但是JMagick只用源码包，需要进行编译安装。尽量将ImageMagick和JMagick安装在同一路径下。</p>
<h6 id="Brew-install-ImageMagick-开始编译JMagick，生成JMagick动态库。"><a href="#Brew-install-ImageMagick-开始编译JMagick，生成JMagick动态库。" class="headerlink" title="Brew install ImageMagick,开始编译JMagick，生成JMagick动态库。"></a>Brew install ImageMagick,开始编译JMagick，生成JMagick动态库。</h6><ul>
<li>遇到JMagick出现找不到api.h文件(实际上在ImageMagick-7是没有这个api.h文件，在ImageMagick-6是有api.h文件):<br>checking magick/api.h usability… no<br>checking magick/api.h presence… no<br>checking for magick/api.h… no<br>configure: error: ‘Unable to find ImageMagick header files’。</li>
</ul>
<p>出现这种情况通过pkg-config、修改configure的参数、查看configure源码，根据报错来修改文件路径，让其能够找到header files等等方法。这些方法都没有解决问题。    </p>
<ul>
<li><a href="http://promiselove.github.io/2017/11/30/Mac%E5%AE%89%E8%A3%85Imagemagick%E5%92%8CJMagick/" target="_blank" rel="noopener">该文章找到原因</a></li>
</ul>
<p>主要是因为JMagick版本老(最新版本是2013更新的)，无法跟上ImageMagick的节奏。ImageMagick的文件位置都发生了很大的变化。(注.看configure源码，可以看到一些文件路径不在了)。</p>
<ul>
<li><p>我们需要做的是：ImageMagick不要安装最新版本，安装旧版ImageMaick6相关版本，并且下载JMagick6.4.0版本。</p>
</li>
<li><p>根据configure的部分源码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Check whether --with-magick-home was given.</span><br><span class="line">if test &quot;$&#123;with_magick_home+set&#125;&quot; = set; then</span><br><span class="line">  withval=$with_magick_home; MAGICK_HOME=$&#123;withval&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for MPATH in /usr /usr/local /usr/local/ImageMagick /usr/local/ImageMagick-$&#123;VER_MAJOR&#125;.$&#123;VER_MINOR&#125;.$&#123;VER_MICRO&#125; $&#123;MAGICK_HOME&#125; ; do</span><br><span class="line">        # Location before IM 6.3.8.something</span><br><span class="line">        if  test -f $&#123;MPATH&#125;/include/magick/api.h  ; then</span><br><span class="line">                MAGICK_LIB_PATH=$&#123;MPATH&#125;/lib</span><br><span class="line">                MAGICK_LIBS=&quot;-L$&#123;MPATH&#125;/lib -lMagick&quot;</span><br><span class="line">                MAGICK_INCLUDES=-I$&#123;MPATH&#125;/include</span><br><span class="line">                MAGICK_REALHOME=$&#123;MPATH&#125;</span><br><span class="line">        fi</span><br><span class="line">        # Location after IM 6.3.8.something</span><br><span class="line">        if  test -f $&#123;MPATH&#125;/include/ImageMagick/magick/api.h  ; then</span><br><span class="line">                MAGICK_LIB_PATH=$&#123;MPATH&#125;/lib</span><br><span class="line">                MAGICK_LIBS=&quot;-L$&#123;MPATH&#125;/lib -lMagick&quot;</span><br><span class="line">                MAGICK_INCLUDES=-I$&#123;MPATH&#125;/include/ImageMagick</span><br><span class="line">                MAGICK_REALHOME=$&#123;MPATH&#125;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>因为编译的该文件的<code>${MPATH}/include/magick/api.h</code>。由于目前include路径下存放的文件多了一层Imagemagick-6，我们要将Imagemagick-6里的所有文件ln -s到include目录下。<br>eg:我的configure命令：</p>
<ul>
<li><p><code>JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/&quot; CFLAGS=&quot;-I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/ -I/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/include/darwin&quot;  ./configure --with-magick-inc-dir=-I/usr/local/Cellar/imagemagick/6.9.10-14/include/ --with-magick-lib-dir=-L/usr/local/Cellar/imagemagick/6.9.10-14/lib/</code></p>
</li>
<li><p><code>./configure --with-java-home=</code>/usr/libexec/java_home<code>--with-java-includes=/System/Library/Frameworks/JavaVM.framework/Headers --with-magick-inc-dir=/usr/local/Cellar/imagemagick@6/6.9.10-14/include/ --with-magick-lib-dir=/usr/local/Cellar/imagemagick@6/6.9.10-14/lib/</code></p>
</li>
</ul>
<p>接下来有些问题下面链接可以解决一部分由<br><a href="https://www.zybuluo.com/yibo/note/125940" target="_blank" rel="noopener">Mac OS X 安装JMagick</a>来解决我们configure的问题。<br>因为还有编译文件中的<code>withval=$with_magick_home; MAGICK_HOME=${withval}</code>,因此我们可以通过增加 – with_magick_home参数，解决某些问题。</p>
<p>make过程中ERROR ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make[1]: Entering directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src&apos;</span><br><span class="line">make[2]: Entering directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src/magick&apos;</span><br><span class="line">make[2]: *** No rule to make target `/usr/local/Cellar/imagemagick/6.9.10-14/include/magick/api.h&apos;, needed by `/usr/local/Cellar/jmagick-6.4.0/6.4.0/obj/magick/magick_PixelPacket.lo&apos;.  Stop.</span><br><span class="line">make[2]: Leaving directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src/magick&apos;</span><br><span class="line">make[1]: *** [dir_target] Error 2</span><br><span class="line">make[1]: Leaving directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src&apos;</span><br><span class="line">make: *** [dir_target] Error 2</span><br></pre></td></tr></table></figure>

<p>因为api.h的路径不对，可以通过ln -s 下。eg: cd /usr/local/Cellar/ &amp;&amp; ln -s ./imagemagick@6/ imagemagick</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make[1]: Entering directory `/Users/yibo/Downloads/6.4.0/src&apos;</span><br><span class="line">make[2]: Entering directory `/Users/yibo/Downloads/6.4.0/src/magick&apos;</span><br><span class="line">../../Make.rules:175: *** missing separator.  Stop.</span><br><span class="line">make[2]: Leaving directory `/Users/yibo/Downloads/6.4.0/src/magick&apos;</span><br><span class="line">make[1]: *** [dir_target] Error 2</span><br><span class="line">make[1]: Leaving directory `/Users/yibo/Downloads/6.4.0/src&apos;</span><br><span class="line">make: *** [dir_target] Error 2</span><br></pre></td></tr></table></figure>

<p>修改Make.rules, 175,176 四个空格换成tab，参见: <a href="http://stackoverflow.com/a/15880079/3368344" target="_blank" rel="noopener">http://stackoverflow.com/a/15880079/3368344</a></p>
<h6 id="make-make-install-成功之后"><a href="#make-make-install-成功之后" class="headerlink" title="make make install 成功之后"></a>make make install 成功之后</h6><p>在/usr/local/lib会生成三个文件</p>
<ul>
<li>jmagick-6.4.0.jar</li>
<li>libJMagick-6.4.0.so</li>
<li>libJMagick.so -&gt; ./libJMagick-6.4.0.so<br>在动态链接库在不同平台的形式：</li>
<li>windows .dll</li>
<li>linux .so</li>
<li>macos .dylib (最新的动态链接库) .jnilib (以前的动态链接库)<br>需要在mac上使用动态链接库，需要使用dylib的后缀的名称。<br>cp libJMagick.so libJMagick.dylib</li>
</ul>
<h5 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h5><p>IDEA的单元测试没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">      String property = System.getProperty(&quot;java.library.path&quot;);</span><br><span class="line">      System.out.println(property);  // 输出/usr/local/lib</span><br><span class="line">      // System.setProperty(&quot;java.library.path&quot;, &quot;/usr/local/lib&quot;);</span><br><span class="line">      // System.loadLibrary(&quot;JMagick&quot;);</span><br><span class="line">      System.out.println(&quot;success&quot;);</span><br><span class="line">      MagickInfo magickInfo = new MagickInfo(&quot;myImage&quot;);</span><br><span class="line">    &#125; catch (MagickException e) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>IDEA的Tomcat需要额外处理：<br>tomcat的VM options增加：<br>-Djmagick.systemclassloader=no -Djava.library.path=/usr/local/lib</p>
<p>参考资料：<br><a href="https://www.zybuluo.com/yibo/note/125940" target="_blank" rel="noopener">Mac OS X 安装JMagick</a><br><a href="http://promiselove.github.io/2017/11/30/Mac%E5%AE%89%E8%A3%85Imagemagick%E5%92%8CJMagick/" target="_blank" rel="noopener">Mac安装Imagemagick和JMagick</a><br><a href="http://noahsnail.com/2016/12/12/2016-12-12-Linux%E7%9A%84pkg-config%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">Linux的pkg-config命令</a><br><a href="https://elf8848.iteye.com/blog/455675" target="_blank" rel="noopener">ImageMagick +Jmagick安装</a>   </p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>phantomjs截图文字不显示</title>
    <url>/2018/12/18/phantomjs%E6%88%AA%E5%9B%BE%E6%96%87%E5%AD%97%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h4 id="PhantomJS-基于-webkit-内核的无界面浏览器"><a href="#PhantomJS-基于-webkit-内核的无界面浏览器" class="headerlink" title="PhantomJS  基于 webkit 内核的无界面浏览器"></a>PhantomJS  基于 webkit 内核的无界面浏览器</h4><blockquote>
<p>webkit:<br>webkit tutorial : <a href="https://www.paulirish.com/2013/webkit-for-developers/" target="_blank" rel="noopener">https://www.paulirish.com/2013/webkit-for-developers/</a><br>中文了解:<br><a href="https://www.jianshu.com/p/a129b05e2216" target="_blank" rel="noopener">https://www.jianshu.com/p/a129b05e2216</a></p>
</blockquote>
<h4 id="学习缘由"><a href="#学习缘由" class="headerlink" title="学习缘由"></a>学习缘由</h4><p>运营活动需要将用户这一年的数据展示出来，用户是可以截图的。<br>当时方案好几个:</p>
<ol>
<li>用户自己手动截图，但是一个用户截图效果有可能会不太好，也太麻烦，最无奈的方案。</li>
<li>通过前端来完成给用户截图的功能。（后续被前端废弃。）</li>
<li>服务端对网页进行截图，然后用户直接下载。（推荐使用PhantomJS）<a id="more"></a>
<h4 id="使用过程和了解"><a href="#使用过程和了解" class="headerlink" title="使用过程和了解"></a>使用过程和了解</h4><a href="http://phantomjs.org/" target="_blank" rel="noopener">phantomjs官网</a><br>下载包分为源码代码包和二进制代码包。<blockquote>
<p>（因为之前不明白centos RPM 包含源码代码包和二进制代码包，碰到了一些麻烦。）</p>
</blockquote>
</li>
</ol>
<p>phantmjs分平台的软件是二进制包，下载就可以使用。<br>但是值得注意的是mac和linux的平台上，有个细节linux需要依赖fonts。<br>一开始我们没有注意这个问题，才有今天的文章。在mac上截图很正常，但是centos服务器截图就是没有文字。</p>
<blockquote>
<p><strong>分析:</strong><br>当时出现在服务器没有显示文字，不明白。</p>
</blockquote>
<ol>
<li>开始怀疑是字体颜色的问题，修改后发现没有效果。</li>
<li>再次认为是JS的原因，通过对请求生成的html进行输出和截图，发现有可能不是html的问题。</li>
<li>最后查阅相关资料，浏览器查找结果有些展示说是字体的问题（因为与字体有关，操作麻烦，直接放弃。想找简单的方法处理），最后没有办法才尝试，字体相关操作。</li>
</ol>
<p><a href="https://bingozb.github.io/51.html" target="_blank" rel="noopener">phantomjs实现服务端屏幕截图</a><br>这篇博客对linux服务端phantomJS截图的做了很深刻的讲解。但是字体使用是微软雅黑。按照这篇博客讲解操作，我们服务器这边截图的字体样式有点难看，太纤细了。</p>
<p>因此将字体变得好看成为重中之重。    </p>
<ol>
<li>查询当前MAC浏览器的字体是什么类型？？ (WhatFont)查询字体 结果：PingFang SC                    </li>
<li>前端指定字体样式:font-family {} 没有效果         </li>
<li>前端@font-face 下载字体 考虑网速的问题，需要压缩字体。没有执行</li>
<li>服务端寻找字体，放到服务器使用。 {最终解决方案} 首选字体PingFang SC</li>
</ol>
<p><a href="http://jser.me/2016/05/31/phantomjs%E5%9C%A8linux%E4%B8%8B%E6%88%AA%E5%9B%BE%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">phantomjs在linux下截图中文字体问题</a><br>给我们很好的思路，尝试拷贝字体。</p>
<ol>
<li>直接mac 命令行拷贝 没有权限失败。</li>
<li>通过mac 命令行 (open /) 打开系统文件，进行/System/Library/Fonts的PingFang.ttc 拖拽拷贝成功。</li>
</ol>
<p>需要将PingFang.ttc的格式转换为linux可用ttf格式。上面博客推荐的转换地址发现，超过了上传文件最大限度。</p>
<ol>
<li><a href="https://www.files-conversion.com/font-converter.php" target="_blank" rel="noopener">Convert Font Files</a> 这个网址转换成功。</li>
</ol>
<p>但是新的问题：浏览器上使用的是PingFang SC字体。linux服务器使用的PingFang字体，导致看到和截图字体样式不一致。</p>
<p>linux 建立字体索引 更新缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir</span><br><span class="line">fc-cache</span><br></pre></td></tr></table></figure>

<h4 id="附赠代码"><a href="#附赠代码" class="headerlink" title="附赠代码"></a>附赠代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; renderImage.js phantomJS 的执行js代码</span><br><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var page = require(&apos;webpage&apos;).create();</span><br><span class="line">var system = require(&apos;system&apos;), pageWidth, pageHeight, pageUrl, format, quality, imagePath;</span><br><span class="line">if (system.args.length != 7) &#123;</span><br><span class="line">    console.log(&apos;Usage: renderImage.js &lt;pageWidth pageHeight pageUrl format quality imagePath&gt;&apos;);</span><br><span class="line">    phantom.exit(1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        pageWidth = system.args[1]</span><br><span class="line">        pageHeight = system.args[2];</span><br><span class="line">        pageUrl = system.args[3];</span><br><span class="line">        format = system.args[4];</span><br><span class="line">        quality = system.args[5];</span><br><span class="line">        imagePath = system.args[6];</span><br><span class="line">&#125;</span><br><span class="line">page.viewportSize = &#123; width: pageWidth, height: pageHeight &#125;;</span><br><span class="line">page.open(pageUrl, function start(status) &#123;</span><br><span class="line">  page.render(imagePath, &#123;format: format, quality: quality&#125;);</span><br><span class="line">  phantom.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; java 执行phantomJS的代码</span><br><span class="line">  /**</span><br><span class="line">    * 将网页渲染成图片</span><br><span class="line">    * format 图片格式 quality 图片质量（0~100）</span><br><span class="line">    * pageWidth 网页宽度 pageHeight 网页高度</span><br><span class="line">    */</span><br><span class="line">   public static void renderImage(String phantomJSPath, String renderImageJSPath, int pageWidth, int pageHeight, String renderUrl, String format, int quality, String outPutImagePath) &#123;</span><br><span class="line">       // 执行命令参数</span><br><span class="line">       List&lt;String&gt; params = Arrays.asList(phantomJSPath, renderImageJSPath, pageWidth + &quot;&quot;, pageHeight + &quot;&quot;, renderUrl, format, quality + &quot;&quot;, outPutImagePath);</span><br><span class="line"></span><br><span class="line">       ProcessBuilder processBuilder = new ProcessBuilder()</span><br><span class="line">               .command(params);</span><br><span class="line">       try &#123;</span><br><span class="line">           processBuilder.redirectError();</span><br><span class="line">           Process process = processBuilder.start();</span><br><span class="line">           InputStream processIS = process.getInputStream();</span><br><span class="line">           String output = IOUtils.toString(processIS);</span><br><span class="line">           logger.info(&quot;渲染成图片: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), output);</span><br><span class="line">           IOUtils.closeQuietly(processIS);</span><br><span class="line">           int result = process.waitFor();</span><br><span class="line">           if (result != 0) &#123;</span><br><span class="line">               logger.warn(&quot;执行失败: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), output);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException | IOException e) &#123;</span><br><span class="line">           logger.warn(&quot;执行失败: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：<br><a href="https://bingozb.github.io/51.html" target="_blank" rel="noopener">phantomjs实现服务端屏幕截图</a><br><a href="http://jser.me/2016/05/31/phantomjs%E5%9C%A8linux%E4%B8%8B%E6%88%AA%E5%9B%BE%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98.html" target="_blank" rel="noopener">phantomjs在linux下截图中文字体问题</a><br><a href="http://phantomjs.org/download.html" target="_blank" rel="noopener">phantmjs下载地址</a><br><a href="https://www.jianshu.com/p/e599ae0c7680" target="_blank" rel="noopener">PingFang sc字体的使用</a><br><a href="http://phantomjs.org/api/webpage/method/open.html" target="_blank" rel="noopener">phantomJS API</a>       </p>
]]></content>
      <tags>
        <tag>phantomjs</tag>
      </tags>
  </entry>
  <entry>
    <title>PERL学习</title>
    <url>/2018/12/05/PERL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>perl 是脚本语言，在工作部署、编译等一些关于linux服务器上的事情都会跟perl打交道。写下自己学习路程，给自己日后总结。</p>
<h3 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a>文档查询</h3><p>perldoc -f xxxx</p>
<h3 id="perl数据类型"><a href="#perl数据类型" class="headerlink" title="perl数据类型"></a>perl数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>定义字符串变量: my $name (my: 定义变量 $: 表示字符串 name: 变量名)<br><strong><em>注意点</em></strong>         </p>
<ul>
<li>内插型字符串<blockquote>
<p>其他变量的数据可以在插入字符串中展示</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my $name = &quot;Inigo MOntoya&quot;;</span><br><span class="line">print &quot;My name is $name&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>非内插型字符串<blockquote>
<p>无论什么字符都直接展示</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print &apos;You may have won $1,000,000&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>转义字符<blockquote>
<p>有些特殊字符需要转义才能正输出</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my $email = &quot;andy@foo.com&quot;;</span><br><span class="line">print $email;</span><br><span class="line"># Prints &quot;andy.com&quot;</span><br><span class="line">解决方案:</span><br><span class="line">my $email = &quot;andy\@foo.com&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h4><ul>
<li>length() 获取字符串长度</li>
<li>subStr() 能够截取字符串</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>创建</p>
</li>
<li><p>访问 $stooges[1]</p>
</li>
<li><p>数组长度 @stooges  scalar @stooges</p>
</li>
<li><p>数组特性</p>
<ul>
<li>数组没有边界</li>
<li>数组合并会平展元素</li>
</ul>
</li>
<li><p>数组操作方法</p>
<ul>
<li>shift 从数组开头移除元素</li>
<li>unshift 将元素添加到数组开头</li>
<li>push 将元素添加到数组的结尾</li>
<li>pop 从数组的结尾移除元素</li>
</ul>
</li>
<li><p>数组高级用法</p>
<ul>
<li><p>提取数组的部分元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my @a = &apos;a&apos;..&apos;z&apos;;</span><br><span class="line">my @vowels = @a[0, 4, 8, 14, 20];</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配数组块 使用splice</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用场景 数组拼接</span><br><span class="line">my @a = qw(Steve Stu Stan);</span><br><span class="line">$a[1] = [&apos;Stewart&apos;, &apos;Zane&apos;];</span><br><span class="line"># @a = (&apos;Steve&apos;, ARRAY(0x841214c), &apos;Stan&apos;)</span><br><span class="line"></span><br><span class="line">my @a = qw(Steve Stu Stan);</span><br><span class="line">splice @a 1, 1, &apos;Stewart&apos;, &apos;Zane&apos;;</span><br><span class="line">#@a = (&apos;Steve&apos;, &apos;Stewart&apos;, &apos;Zane&apos;, &apos;Stan&apos;)</span><br></pre></td></tr></table></figure>

<ul>
<li>利用map处理数组 (<strong>map 本质上是返回列表的foreach 循环</strong>)map</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my @ARRAY = (1, 2, 3, 4, 5);</span><br><span class="line">my %hash = map &#123;$_ =&gt; $_ * 9&#125; @ARRAY;</span><br><span class="line"># %hash = (1 =&gt; 9, 2 =&gt; 18, 3 =&gt; 27, 4 =&gt; 36, 5 =&gt; 45)</span><br></pre></td></tr></table></figure>

<ul>
<li>grep从数组中选择项目 (<strong>grep 本质上返回列表foreach循环</strong>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my @ARRAY = (1, 2, 3, 4, 5);</span><br><span class="line">my @NEWARRAY = grep &#123;$_ * 9&#125; @ARRAY</span><br><span class="line">&#123;&#125; 包含表达式的意思</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希就是键值对</p>
<ul>
<li>创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.方法一</span><br><span class="line">my %stooges = (</span><br><span class="line">  &apos;Moe&apos;, &apos;Howard&apos;,</span><br><span class="line">  &apos;Larry&apos;, &apos;Fine&apos;,</span><br><span class="line">  );</span><br><span class="line">2. 方法二</span><br><span class="line">my %stooges = (</span><br><span class="line">  Moe =&gt; &apos;Howard&apos;,</span><br><span class="line">  Larry =&gt; &apos;Fine&apos;,</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希转数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my @hash_array = %stooges;</span><br><span class="line"># Contains (&apos;Moe&apos;, &apos;Howard&apos;, &apos;Larry&apos;, &apos;Fine&apos;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用{}操作哈希<br>输出哈希值 更改哈希值 删除哈希条目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print $stooges&#123;&apos;Moe&apos;&#125;;</span><br><span class="line">#Prints &quot;Howard&quot;;</span><br><span class="line">$stooges&#123;&apos;Moe&apos;&#125; = &apos;NiHao&apos;;</span><br><span class="line">delete $stooges&#123;&apos;Moe&apos;&#125;;</span><br><span class="line">unlink $stooges&#123;&apos;Moe&apos;&#125;;</span><br><span class="line">delete 不会删除文件 unlink 为删除文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>哈希的键/值数组</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my @key = keys %stooges;</span><br><span class="line">my @value = values %stooges;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>哈希特点</p>
<ul>
<li>哈希是无序的</li>
<li>无法排序</li>
</ul>
</li>
<li><p>哈希define exist的差异</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>perl</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式（经典讲解）</title>
    <url>/2018/10/21/regular-expression/</url>
    <content><![CDATA[<h4 id="正则表达式-regular-expression（经典讲解）"><a href="#正则表达式-regular-expression（经典讲解）" class="headerlink" title="正则表达式 regular expression（经典讲解）"></a>正则表达式 regular expression（经典讲解）</h4><blockquote>
<p>说明：所谓经典讲解，是作者个人直观感觉。个人以前看过大量“正则表达式”的博客文章，但是始终未能深刻理解正则表达式。但是最近一篇有关linux的书籍（开源旅行手册）提到正则表达式，让我醍醐灌顶。</p>
</blockquote>
<blockquote>
<p>说明：本文内容主要来自《OS WORLD TRIP》又名《开源世界旅行手册》,由<strong>Kardinal</strong>著。该书的源地址：<a href="https://linuxtoy.org/pages/download.html" target="_blank" rel="noopener">下载地址</a> 。正则表达式的内容在部分2:地理的第26章</p>
</blockquote>
<a id="more"></a>
<h4 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h4><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>&emsp;&emsp;对于文本内容的处理，通常使用交互方式，手工调整;但如果你对源文本比较了解，则可以采用自动化的批量处理方式，这种方式效率高、迅速快批量处理，要求根据一定规则，匹配源文本中的字符，转换为目标文本，这就要用到正则表达式。<br>最简单的例子，使用 regular 进行匹配，结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`regular` expression</span><br></pre></td></tr></table></figure>

<p>正则表达式有许多变种:glob 表达式、基本正则表达式、perl 正则表达式、emacs 正则表达式……      </p>
<h6 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h6><p>&emsp;&emsp;正则表达式与数学表达式的不同在于，数学表达式执行数学运算，而正则表达式执行字符运算;相同的是，它们都按一定的优先级进行运算</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">转义符</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">捕获、匹配、断言</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">字符类</td>
</tr>
<tr>
<td align="center">*+?</td>
<td align="center">限定符</td>
</tr>
<tr>
<td align="center">{}</td>
<td align="center">范围</td>
</tr>
<tr>
<td align="center">^$</td>
<td align="center">位置和顺序</td>
</tr>
<tr>
<td align="center">&#124;</td>
<td align="center">或</td>
</tr>
</tbody></table>
<h6 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h6><p>&emsp;&emsp;如果源文本中出现了正则表达式中的运算符，如 ( ，使用 <code>(</code> 无法匹配下列文本中的括弧，这时要使用 <code>\</code> 进行转义。用 <code>\(</code> 匹配。在 Emacs 和 Vim 正则表达式中正好反过来，使用 <code>\(</code> 表示分组，用 <code>(</code> 匹配字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`(`regular expression)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在文本中匹配“运算优先级”一节中的所有运算符,都要用这种形式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\运算符</span><br><span class="line">如 \* \+ \- \\的使用</span><br></pre></td></tr></table></figure>

<p>在文本中匹配 <code>\</code> 本身，要用 <code>\\</code>。<br>非运算符前使用 <code>\</code>，则有特殊的意义，例如 <code>\n</code> 匹配一个换行符。常用转义字符:   </p>
<h5 id="常规匹配"><a href="#常规匹配" class="headerlink" title="常规匹配"></a>常规匹配</h5><table>
<thead>
<tr>
<th>转义字符</th>
<th>涵义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束，在字符类里代表退格</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始，在字符类里表 示”非“</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
<tr>
<td>[aeiou]</td>
<td>字符集合,匹配所包含的任意一个字符</td>
</tr>
</tbody></table>
<h5 id="反向匹配"><a href="#反向匹配" class="headerlink" title="反向匹配"></a>反向匹配</h5><table>
<thead>
<tr>
<th>转义字符</th>
<th>涵义</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou 这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><table>
<thead>
<tr>
<th>转义字符</th>
<th>涵义</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一 声)</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII 代码中八进制代码为 nn 的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII 代码中十六进制代码为 nn 的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode 代码中十六进制代码为 nnnn 的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII 控制字符。比如 \cC 代表 Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似^，但不受处理多行 选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选 项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似$，但不受处理多行 选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
</tbody></table>
<h5 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h5><p>&emsp;&emsp;要想匹配数字、字母、空白很容易，因为已经有了对应这些字符集合的转义符，但是如果你 想匹配没有预定义的字符集合(比如元音字母 a、e、i、o、u)，应该怎么办?<br>&emsp;&emsp;正则表达式中允许你自定义字符类，在方括号里列出它们就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[aeiou]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;预定义的字符集合，也可以用字符类表示，如 <code>\d</code> 等价于 [0-9] 有些运算符，在字符类中使用会有另一种意义，例如 ^ 表示“字符串开始”，但在字符类中却<br>表示 “非”，以 <code>expression</code> 为例，使用 [exp] 匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`exp`r`e`ssion</span><br></pre></td></tr></table></figure>

<p>使用 [^exp] 匹配(字符串中非 e、x、p 的字符):    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exp`r`e`ssion`</span><br></pre></td></tr></table></figure>

<p>而使用 ^[exp] 匹配(以 e、x 或 p 起始的字符串):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`e`xpression</span><br></pre></td></tr></table></figure>

<h5 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h5><p>&emsp;&emsp;在上一小节中的表格中，我们知道<code>.</code> 可以匹配除换行符以外的任意字符，使用<code>.</code> 匹配下列 文本:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression</span><br></pre></td></tr></table></figure>

<p>但是 <code>.</code> 每次只匹配一个字符，如果想一次匹配多个，则要使用限定符。</p>
<p>|贪婪限定符|惰性限定符|作用|<br>|—–|—–|<br>|<em>|</em>?|匹配零次或多次|<br>|+|+?|匹配一次或多次|<br>|?|??|匹配零次或一次|<br>|{3}|{3}?|匹配三次|<br>|{3,5}|{3,5}?|匹配三到五次|<br>|{3,}|{3,}?|匹配三次或以上|</p>
<p>下面通过实例了解限定符的区别。 es 的匹配结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr`es`sion</span><br></pre></td></tr></table></figure>

<p>es+ 的匹配结果(e，一个或多个 s)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr`ess`ion</span><br></pre></td></tr></table></figure>

<p>es* 的匹配结果(e，零或多个 s)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`e`xpr`ess`ion</span><br></pre></td></tr></table></figure>

<p>es? 的匹配结果(e，零或一个 s)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`e`xpr`es`sion</span><br></pre></td></tr></table></figure>

<p><strong>贪婪与懒惰</strong><br>&emsp;&emsp;使用限定符进行匹配时，默认匹配尽可能多的字符。无论用 <code>.*</code> 还是 <code>.+</code>匹配下列文本，都会匹配全部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`expression`</span><br></pre></td></tr></table></figure>

<p>这种方式称为“贪婪模式”。在限定符之后加 <code>?</code> 则匹配尽可能少的字符，称为“懒惰模式”。 (懒惰模式的详解：<code>.+</code> 匹配一个或多个任意字符，在贪婪模式中，它匹配尽可能多的字符;而懒惰模式中(<code>.+?</code>)，则只匹配一个字符; <code>.{3,5}</code> 在贪婪模式中尽可能匹配5个字符，在懒惰模 式中(<code>.{3,5}?</code>)只匹配3个字符; <code>?</code>和 <code>*</code> 这样可以匹配零次的限定符，在懒惰模式下不匹配任何字符( <code>.*?</code>、<code>.??</code> ))。<br>例如，使用贪婪模式 a.+b 匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`aaabab`</span><br></pre></td></tr></table></figure>

<p>使用懒惰模式 a.+?b 匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`aaab`ab</span><br></pre></td></tr></table></figure>

<h5 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h5><p><code>|</code> 表示“或”，使用它进行分支选择:<br>例如 <code>[a-z]+|\d+</code> 匹配单词或数字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression 123</span><br></pre></td></tr></table></figure>

<h5 id="分组、捕获、不捕获"><a href="#分组、捕获、不捕获" class="headerlink" title="分组、捕获、不捕获"></a>分组、捕获、不捕获</h5><h6 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h6><p>&emsp;&emsp;使用<code>(表达式)</code>对表达式进行分组，即用小括号来指定子表达式叫做分组。例如使用 <code>(\d{3}\.){2}</code> 匹配下面例子中的数字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc`123.456.`def</span><br></pre></td></tr></table></figure>

<p><code>\d{3}</code> 表示三个数字， <code>(\d{3}\.)</code> 表示三个数字加<code>“ . ”</code>为一组，<code>{2}</code> 表示这一组内容重复两次</p>
<h6 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h6><p>&emsp;&emsp;在对表达式进行分组的时候，会捕获文本到自动命名的组里。可以使用 <code>\1 \2 ......</code> 来反向引用组。例如用 <code>([a-z]*)\s(\d*)</code> 匹配下列文本， <code>([a-z]*)</code> 为 <code>\1</code> 组， <code>(\d*)</code> 为 <code>\2</code> 组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`kardinal 1234567`</span><br></pre></td></tr></table></figure>

<p>使用 <code>\2\s\1</code> 替换 <code>([a-z]*)\s(\d*)</code> ，可以改变两个字符串的顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567 kardinal</span><br></pre></td></tr></table></figure>

<p>使用<code>([a-z]*)\s(\d*)\1</code>匹配下列文本，<code>([a-z]*)</code> 为 <code>\1</code> 组， <code>(\d*)</code> 为 <code>\2</code>组，<code>([a-z]*)\s(\d*)\1</code>中<code>\1</code>是反向引用组:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`kardinal 1234567kardinal`</span><br></pre></td></tr></table></figure>

<p>如果分组较多，计数可能会不太方便，可以给分组指定名称，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?&lt;name&gt;[a-z]*)\s(?&lt;num&gt;\d*)  name、num 是分组的名称</span><br><span class="line">\k&lt;num&gt;\s\k&lt;name&gt; (?#使用“`\k&lt;name&gt;`”反向引用)</span><br></pre></td></tr></table></figure>

<p>使用 <code>(?:表达式)</code> ，则只是分组，而不捕获，下面例子中， <code>(\d*)</code> 为 <code>\1</code> 组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?:[a-z]*)\s(\d*)</span><br></pre></td></tr></table></figure>

<p>不捕获的典型应用：<br>用使用在或的应用中，使用或需要使用括号即捕获组，但是又不想存在捕获组，则可以使用不捕获。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l(?:i|o|e)ve</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注明：反向引用提供了标识字符串中的重复字符或子字符串的方便途径。 例如，如果输入字符串包含某任意子字符串的多个匹配项，可以使用捕获组匹配第一个出现的子字符串，然后使用反向引用匹配后面出现的子字符串。捕获文本放入对应的分组是需要消耗内存的。如何后续不反向引用分组，可以采用捕获但是不分组。</p>
</blockquote>
<h6 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h6><p>&emsp;&emsp;目前为止，我们学到的正则表达式匹配，都是有“宽度”的，使用 <code>\w+</code>。 匹配下面文本，会将 <code>。</code> 一同匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regular。</span><br><span class="line">expression。</span><br></pre></td></tr></table></figure>

<p>如果不想匹配符号，只匹配一个位置，就要用到“零宽断言”(匹配宽度为零，满足一定的条件的断言)，零宽断言使用 (?=表达式) 的语法，例如 <code>\w+(?=。)</code> ，其中 <code>(?=。)</code> 表示<code>。</code> 前面的位置(先行断言)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`regular`。</span><br><span class="line">`expression`。</span><br></pre></td></tr></table></figure>

<p>高级应用(关于为什么叫零宽断言)：<br>表达式写法：<code>\w+(?=。)。\w+</code> | <code>\w+(?=。)\w+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`regular。zero`</span><br></pre></td></tr></table></figure>

<p>如果需要匹配后面的位置，如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">。`regular`</span><br><span class="line">。`expression`</span><br></pre></td></tr></table></figure>

<p>则要用到后发断言 <code>(?&lt;=。)</code> ，使用 <code>(?&lt;=。)\w+</code> 得到上面的匹配结果<br>使用 <code>(?&lt;=&lt;b&gt;).*(?=&lt;/b&gt;)</code> 匹配标签中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;`粗体`&lt;/b&gt;</span><br></pre></td></tr></table></figure>

<h6 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h6><p>&emsp;&emsp;负向零宽断言 <code>(?!表达式)</code> 也是匹配一个零宽度的位置，不过这个位置的“断言”取表达式的反值，例如 <code>(?!表达式)</code> 表示 <code>表达式</code> 前面的位置，如果 <code>表达式</code> 不成立，匹配这个位置;如果 <code>表达式</code> 成立，则不匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`expression`</span><br><span class="line">expression。</span><br><span class="line">`expression`，</span><br><span class="line">`expression`;</span><br></pre></td></tr></table></figure>

<p>以上为使用 <code>.+n(?!。)</code> 的匹配结果。注意与 <code>.+n[^。]</code> 匹配的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression</span><br><span class="line">`expression，`</span><br><span class="line">`expression;`</span><br><span class="line">expression。</span><br></pre></td></tr></table></figure>

<p>同样，负向零宽断言也有“先行”和“后发”两种，负向零宽后发断言为 <code>(?&lt;!表达式)</code> 使用 <code>(?&lt;![&lt;/])para(?!&gt;)</code> 匹配下面文本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;para&gt;`para`表示一个段落&lt;/para&gt;</span><br></pre></td></tr></table></figure>

<p><code>(?&lt;![&lt;/])</code> 表示 para 左边不能为 <code>&lt;</code> 或 <code>/</code> ; <code>(?!&gt;)</code> 表示 para 右边不能为 <code>&gt;</code>。</p>
<h6 id="常用分组语法"><a href="#常用分组语法" class="headerlink" title="常用分组语法"></a>常用分组语法</h6><table>
<thead>
<tr>
<th>分类</th>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>捕获</td>
<td>(exp)</td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td></td>
<td>(?exp)</td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td></td>
<td>(?:exp)</td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>零宽断言</td>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
</tr>
<tr>
<td></td>
<td>(?!exp)</td>
<td>匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td></td>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
</tr>
<tr>
<td>注释</td>
<td>(?#comment)</td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody></table>
<p>推荐其他网址<br><a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则表达式全集</a><br><a href="https://www.kancloud.cn/thinkphp/regex-guide/43534" target="_blank" rel="noopener">正则表达式简明参考</a> (重点在分组和反向引用)<br><a href="https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/chapter3.html" target="_blank" rel="noopener">正则表达式30分钟教程</a> (常用分组语法的总结)<br><a href="http://blog.51cto.com/cnn237111/749047" target="_blank" rel="noopener">正则表达式的先行断言(lookahead)和后行断言(lookbehind)</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS内网测试和外网更新</title>
    <url>/2018/10/08/CORS%E5%86%85%E7%BD%91%E6%B5%8B%E8%AF%95%E5%92%8C%E5%A4%96%E7%BD%91%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h5 id="解释CORS的定义"><a href="#解释CORS的定义" class="headerlink" title="解释CORS的定义"></a>解释CORS的定义</h5><p>CORS （Cross-origin resource sharing）跨域资源共享问题，是W3C的标准。    </p>
<blockquote>
<p>当某一资源在自己的资源服务器上的不同域或者端口请求另一个资源时，那么该资源会发起一次跨域请求. (Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional HTTP headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a cross-origin HTTP request when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.)    </p>
</blockquote>
<p>个人理解：我（浏览器）在小明家（服务器）的正门（端口）借东西（资源）。突然还需要其他东西，但是不是小明给我，或者不是正门给我是在侧门给我，那我怎么能够相信这个东西有没有毒啊，有没有进过其他人的手。对于这种情况呢，我就给一个信物（Origin）给小明（服务器），只有小明（服务器）知道信物交换的秘密，正确的情况会把信物翻版（Access-Control-Allow-Origin）给我，不正确就直接不要。</p>
<a id="more"></a>
<h5 id="哪些情况会出现CORS的问题"><a href="#哪些情况会出现CORS的问题" class="headerlink" title="哪些情况会出现CORS的问题"></a>哪些情况会出现CORS的问题</h5><p>我遇到的HTTPS在CHROME浏览器出现跨域字体无法显示,在safari和HTTP的情况没有出现。<br><a href="https://segmentfault.com/a/1190000007326671" target="_blank" rel="noopener">详细介绍哪些情况会出现跨域的情况列链接</a>并前端的角度该如何解决问题。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是由浏览器自动在头信息中增加一个 Origin 字段。然后只需要在返回的相应上加上Access-Control-Allow-Origin:[Origin]|* 。<br><a href="https://zoctan.github.io/2018/07/21/%E5%AD%A6%E4%B9%A0/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%20CORS%20%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89/" target="_blank" rel="noopener">前端详细介绍了解</a></p>
<h5 id="接下来详细讲实际解决的情况"><a href="#接下来详细讲实际解决的情况" class="headerlink" title="接下来详细讲实际解决的情况"></a>接下来详细讲实际解决的情况</h5><ul>
<li>需要让内网出现线上的情况</li>
<li>按照网上解决方案去解决</li>
<li>线上CDN资源需要让其失效</li>
</ul>
<h6 id="内网配置出线上环境"><a href="#内网配置出线上环境" class="headerlink" title="内网配置出线上环境"></a>内网配置出线上环境</h6><p>我们内网是http协议，不支持https的协议，没有出现线上的情况。</p>
<ul>
<li>先需要将线上的证书下载到本地，在上传到内网指定位置。</li>
<li>先将内网的nginx的配置文本上加上https的443的端口访问处理。(/opt/nginx/conf/conf.d)</li>
<li>证书和域名是一一对应，所有配置文件的server-name 为证书上的域名。<blockquote>
<pre><code>server {
  listen 443;
  server_name #证书上的域名即线上的网址
  access_log  #日志地址
  ssl    on;
  ssl_certificate   #证书地址
  ssl_certificate_key    #证书地址
  location ~ / {
          proxy_http_version 1.1;
          proxy_set_header Connection &quot;&quot;;
          proxy_set_header  X-Real-IP  $remote_addr;
          proxy_set_header  FORWARDED-FOR  $remote_addr;
          proxy_pass #代理到Tomcat的服务器的域名+端口
          include conf.d/proxy_params;}}</code></pre></blockquote>
</li>
</ul>
<p>1.遇到问题只能通过线上域名访问，但是无法访问到内网的资源。<br>2.<a href="https://www.jianshu.com/p/4394aaf97492" target="_blank" rel="noopener">DNS 服务详细了解</a></p>
<blockquote>
<p>先了解客户端进行域名解析的流程：<br>先查hosts文件<br>若没有，查本地DNS缓存<br>若没有，再查DNS服务器：<br>先查DNS服务器的本地DNS缓存<br>若没有，再查DNS服务器的解析库<br>都没有，那DNS向根域发起请求，开始迭代查询<br>如果缓存的有效期为1天的话，能极大减轻DNS服务器的压力，所以对于DNS的架构，“缓存”是很重要的。</p>
</blockquote>
<p>3.在/etc/hosts文件加上ip和域名的强制映射(内网ip（nginx） 线上域名）。我们的nginx和tomcat服务器是在同一个服务器上。 接下来线上域名的访问都会转接到内网资源的访问。（另一个办法：通过Charles进行代理实现）<br>4.详细分析后，字体是加载进来的js代码发起的静态资源访问（CORS的访问，二级域名不一样）。折腾好久才想起来的，但是静态资源的访问是通过不同内外网环境进行变化的，内网静态资源都在内网服务器上，外网的静态资源在CDN缓存上和静态资源服务器上。<br>5.将加载js的代码写死，变成直接访问外网的静态资源。（与线上保持一致）<br>6.静态资源访问需要变成内网资源的访问。同样，先在hosts文件加上ip和静态资源的域名的强制映射（内网ip  线上域名）。<br>内网静态资源nginx配置         </p>
<blockquote>
<pre><code>server {
           listen 443;
           server_name #静态资源服务器
           gzip on;
   ssl    on;
   ssl_certificate    /data/config/ssl/star.enjoymeet.com.chained;
   ssl_certificate_key    #证书地址
   access_log  #证书地址
   location ~* \.(eot|ttf|woff|woff2)$ {
          add_header  Access-Control-Allow-Origin * ;
          add_header Access-Control-Allow-Methods GET;
          proxy_pass #代理到Tomcat的服务器的域名+端口
   }
 }</code></pre></blockquote>
<p>基本上实现在内网测试。<br>参考资料：在nginx上解决问题<br><a href="http://www.yunweipai.com/archives/9381.html" target="_blank" rel="noopener">Nginx通过CORS实现跨域1</a><br><a href="https://hk.saowen.com/a/bcc2bf629fad4037006703f159ec7927ef4cca06a0d7a2cf6d8932584754fa28" target="_blank" rel="noopener">Nginx通過CORS實現跨域2</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）
</a><br><a href="https://serverfault.com/questions/162429/how-do-i-add-access-control-allow-origin-in-nginx" target="_blank" rel="noopener">How do I add Access-Control-Allow-Origin in NGINX?</a></p>
<h6 id="线上处理"><a href="#线上处理" class="headerlink" title="线上处理"></a>线上处理</h6><ul>
<li>CDN 回源，我们回源的访问80端口欧，HTTP协议。</li>
<li>CDN的资源让线上的资源失效。</li>
</ul>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义程序朗读单词文本</title>
    <url>/2018/10/06/speackEnglishWord/</url>
    <content><![CDATA[<h4 id="自定义程序朗读单词文本意思"><a href="#自定义程序朗读单词文本意思" class="headerlink" title="自定义程序朗读单词文本意思"></a>自定义程序朗读单词文本意思</h4><p>其核心内容是围绕Mac Terminal终端say命令展开的
让学习英语就像听歌一样简单</p>

<h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><ul>
<li>简单使用say去读一小段的文本 say Hello World;</li>
<li>学习使用say去读文件 say -f …/…/hello_world.txt|.csv</li>
<li>详细使用可以输入命令 man say</li>
</ul>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><ul>
<li>寻找合适单词翻译网站 通过复制粘贴的形式到文件中</li>
<li>目前我使用的是<a href="https://www.shanbay.com/" target="_blank" rel="noopener">扇贝网站</a>的单词学习<a id="more"></a>
<h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5></li>
<li>编写自己的程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/perl</span><br><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line"></span><br><span class="line">use Time::HiRes qw(usleep nanosleep);</span><br><span class="line"></span><br><span class="line"># 获取文件参数</span><br><span class="line">my $file = $ARGV[0] or die &quot;Need to get CSV file on the command line\n&quot;;</span><br><span class="line"># 打开文件</span><br><span class="line">open(my $data, &apos;&lt;&apos;, $file) or die &quot;Could not open &apos;$file&apos; $!\n&quot;;</span><br><span class="line"># 一行一行的读文件</span><br><span class="line">while (my $line = &lt;$data&gt;) &#123;</span><br><span class="line">  usleep(500);</span><br><span class="line">  # 去除回车键</span><br><span class="line">  chomp $line;</span><br><span class="line">  # 一行文本按照空格符的进行分割成组</span><br><span class="line">  my @strWord = split(/[\s+]/, $line);</span><br><span class="line">  foreach(@strWord)&#123;</span><br><span class="line">     if($_  !~ /\./)&#123;</span><br><span class="line">     `say &quot;$_&quot;`;</span><br><span class="line">      if($_ =~ /\w+/)&#123;</span><br><span class="line">          my $size = length($_);</span><br><span class="line">         my $strIndex = 0;</span><br><span class="line">         my $strEnd = $strIndex + 1;</span><br><span class="line">          while($strIndex &lt; $size)&#123;</span><br><span class="line">          my $subWord = substr($_, $strIndex, 1);</span><br><span class="line">          `say &quot;$subWord&quot;`;</span><br><span class="line">         $strIndex = $strIndex + 1;</span><br><span class="line">         &#125;</span><br><span class="line">       usleep(500);</span><br><span class="line">      # say 单词和单词的释义</span><br><span class="line">       `say &quot;$_&quot;`;</span><br><span class="line">      &#125;</span><br><span class="line">      print &quot;$_  &quot;;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  print &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过perl命令执行程序 eg: perl readCSV.pl /Users/useheart/学习资料/英语单词学习.csv</li>
</ul>
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
