<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac os thrift旧版本安装爬坑指南]]></title>
    <url>%2F2019%2F06%2F01%2FMacOS%20thrift%E6%97%A7%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Mac os thrift旧版本安装爬坑指南喜欢使用brew来进行一键安装: homebrew官网homebrew-core github网址 对于安装最新新版本thrift,我们可以直接是用brew install thrift 使用brew search thrift;查看不同版本的thrift。然后brew install thrift@0.9.0 使用复杂brew方案进行安装。思路同时通过找到旧版本的thrift.rb。 将homebrew-core的git文件下载到本地。 通过查看Formula/thrift.rb的history。 git log 234b34ab1418bd42b14e73dbeea179f40ef1bec2 -- Formula/thrift.rb 找到旧版本的commit。 12345 commit 9d524e4850651cfedd64bc0740f1379b533f607dAuthor: BrewTestBot &lt;brew-test-bot@googlegroups.com&gt;Date: Thu Dec 29 18:54:26 2016 +0000 thrift: update 0.9.3 bottle. 然后将链接 123https://github.com/Homebrew/homebrew-core/blob/&#123;commit_id&#125;/Formula/thrift.rb即:https://github.com/Homebrew/homebrew-core/blob/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb 点击页面上按钮“Raw”,获取文件内容 123https://raw.githubusercontent.com/Homebrew/homebrew-core/&#123;commit_id&#125;/Formula/thrift.rb即:https://raw.githubusercontent.com/Homebrew/homebrew-core/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb 在命令行上 brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/9d524e4850651cfedd64bc0740f1379b533f607d/Formula/thrift.rb即可。安装成功。 参考网址:Install older removed brew formula version 源码安装 thrift快速指南 下载旧版本 安装下载thrift要求的其他工具|插件 配置、编译、安装 开始爬坑 安装前要求工具 可以使用brew install 进行安装 https://thrift.apache.org/docs/install/os_xboostlibeventopensslbison 2.5 下载thrift文件安装包 https://github.com/apache/thrift/releases/tag/0.9.3tar -zxvf 解压 编译流程 ./configure –prefix=/usr/local/ –disable-static –without-python –without-csharp –without-ruby –without-perl –without-php –without-haskell –without-erlanghttps://thrift.apache.org/docs/BuildingFromSource出现bison版本低: https://stackoverflow.com/questions/31805431/how-to-install-bison-on-mac-osx注意需要source .base_profile 出现问题： src/thrift/transport/TSSLSocket.cpp:33:10: fatal error: ‘openssl/err.h’ file not found #include &lt;openssl/err.h&gt;https://www.jianshu.com/p/f7380139afdd 推荐阅读:编译器的工作过程]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx控制http转https]]></title>
    <url>%2F2019%2F06%2F01%2Fnginx%E6%8E%A7%E5%88%B6http%E8%BD%AChttps%2F</url>
    <content type="text"><![CDATA[nginx控制http转https 现在越来越多的公司选择https的协议。我司的做法: nginx上进行https的认证，在请求在交给tomcat进行处理。而tomcat处理的是http的请求。因为当进行tomcat应用程进行重定向时直接使用http的请求在处理。 为了保证整个请求都是https请求。我们需要将返回的请求进行重定向为https的。 通过proxy-redirect修改Location中的url。 将 conf/conf.d/proxy_params文件中 proxy_redirect off; 注释掉2.将proxy_redirect http://www.xxxxx.com/ https://www.xxxxx.com/;proxy_redirect http://xxxxx.com/ https://xxxx.com/;放入到server {}块中。 如果一直使用http的协议，容易出现网页中有代码注入广告的现象。运营商就经常将小广告注入到网页中，一般是网页的右下角有个摆动的小图标。使用https的协议，能够降低这一现象。不过一山更比一山高，https的也会有网页代码注入的现象，不过特别隐蔽。我遇到表现是打开应用的中网页时会启动其他应用程序如京东、淘宝。对这一现象的说明和解决方案 参考资料:Nginx SSL 结合Tomcat 重定向URL变成HTTP的问题]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP大文件上传思路和总结]]></title>
    <url>%2F2019%2F06%2F01%2FHTTP%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTTP大文件上传思路和总结无法http大文件一次性上传的原因 存在文件上传大小的限制 默认一般nginx和tomcat都会对上传文件大小进行限制nginx的配置文件nginx.conf设置 client_max_body_size 20m; tomcat默认设置能接收HTTP POST请求的大小最大为2M。如果POST请求传递的数据大于2M,就会报错误。解决方案：修改tomcat的配置server.xml中标签,在该标签中添 加”maxPostSize”属性,将该属性值设置成你想要的最大值,单位是字节,或者把这个值设置为 0(maxPostSize=”0”)。 Tomcat项目的web配置。工程项目web.xml的配置 12345678&lt;servlet&gt;&lt;multipart-config&gt;&lt;location&gt;&lt;/location&gt;&lt;max-file-size&gt;&lt;/max-file-size&gt;&lt;max-request-size&gt;&lt;/max-request-size&gt;&lt;file-size-threshold&gt;&lt;/file-size-threshold&gt;&lt;/multipart-config&gt;&lt;/servlet&gt; Spring配置文件限制上传文件的大小 1234&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;41943040&quot; /&gt; &lt;!-- 40mb --&gt; &lt;/bean&gt; 解决方案错误方案1:1、分片上传大文件2、服务端将每片文件存成临时文件，然后在进行合并文件。存在无核实合并文件是否正确的问题 错误方案2:md5文件摘要，确保合并文件没有问题。存在重复造轮子问题。在分布式服务器中进行分片上传无法控制同一个服务器上 前端选择WebUploader进行上传。后端没有选择控制nginx路由到指定服务器，而是选择单点文件上传服务thrift。 单点文件上传服务thrift提供功能 存储分片文件和合并分片文件进行存储 获取文件上传的状态 前后端交互流程： 前端向服务器获取上传文件的唯一标识。（可以写入数据库获取id标识） 前端将指定文件md5，分片上传 {file,chunk,chunks,md5value,唯一id标识, 额外自定义字段} 服务端检查是否存在唯一id标识，校验参数正确性 调用单点文件上传服务，存储指定文件路径夹下（使用 md5Value+userId+唯一id标识 作为唯一文件夹名称） 单点文件上传服务通过对分片文件进行排序统计返回是否可以进行合并文件操作。 | 单点文件上传服务通过对分片文件进行排序统计返回是否正在进行合并操作。 前端收到合并信息停止上传文片文件并调用服务端进行文件合并。 服务端清理相关的文件夹。 当前端接收上传失败的信息，需要调用服务端清理相关文件的操作。 安卓APK文件上传（不是特别规范，有待以后自己多加研究） 前端分片文件 -&gt; 服务端 -&gt; 单点文件服务 单点文件服务是否在合并文件 -&gt; 服务端 -&gt; 前端 这一步就是为了让服务端分片不去占用磁盘。降低出错下，产生大量临时文件 前端删除分片文件 -&gt; 服务端 -&gt; 单点文件服务 单点文件服务删除分片文件 -&gt; 服务端 -&gt; 前端 增加这一步的原因：APK远程上传到CDN上耗时较长，容易超过request时间。改用轮询来处理，让界面不卡死，容易有反馈。 前端获取APK文件上传状态 -&gt; 服务端 -&gt; 单点文件服务 单点文件服务APK上传状态 -&gt; 服务端 -&gt; 前端 推荐了解网址:大文件分步式分片上传和续传聊聊大文件上传HTTP文件上传的一个后端完善方案（NginX）大文件上传解决方案]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA小技巧]]></title>
    <url>%2F2019%2F02%2F12%2FIDEA%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[提供IDEA使用小技巧 推荐一些本人亲身尝试，在实际开发中比较实用的小技巧，可以大大提高开发效率。 IDEA左侧显示打开代码文件和资源文件 应用场景:默认IDEA的代码文件的Tab放在代码区的上方。但是实际开发，我们经常打开很多代码文件，左侧显示整体显示，可以提高管理打开代码文件。 结果 操作步骤: IDEA多个模块同名分支统一切换 （Multi-root same name brances change） 应用场景:默认IDEA的分支操作:模块分支统一操作(Common Local Branches)和单模块分支操作(Local Branches)。 对于某个模块同名的分支的处理很难处理。 (类似问题:https://stackoverflow.com/questions/13797331/intellij-switching-between-multiple-git-local-branches) 灵感来自这篇文章:Task Management does not respect “Execute branch operations on all roots” setting 操作步骤Click “Tools” &gt; “Tasks &amp; Contexts” &gt; “Open Task” IDEA的编辑区不换行操作]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOX安装JMagick]]></title>
    <url>%2F2019%2F01%2F29%2FMacOX%E5%AE%89%E8%A3%85JMagick%2F</url>
    <content type="text"><![CDATA[MacOX安装JMgick原因和使用JMagick执行流程 目前对于图片处理，很少采用java去处理图片，性能不是很好。目前我们公司采用ImageMagick图片处理，有些采用Process执行cmd命令，有些采用jmagick的java接口进行处理。 ImageMagick官网通过jmagick调用native方法来调用JMagick的方法, 再由JMagick调用ImageMagick的方法。jmagick使用Java代码写的。JMagick使用C语言写的，含有java JNI生成的头文件。ImageMagick使用C语言写的，没有含有java JNI生成的头文件。 ImageMagick介绍和执行流程原因解释 执行流程: jmagick（java） –&gt; JMagick(C) –&gt; ImageMagick(C) 本地MacOX执行遇到问题new MagickInfo(“”); 调用时出现无法加载MagickLoader，实际无法加载资源JMagick；123456ClassLoader.getSystemClassLoader().loadClass(&quot;magick.MagickLoader&quot;).newInstance();public class MagickLoader &#123; static &#123; System.loadLibrary(&quot;JMagick&quot;); &#125;&#125; 因为jmagick的接口都是本地调用，需要加载JNI的JMagick动态库。因此，接下来我们的主要任务是生成JMagick的动态库。通过Brew install ImageMagick直接安装使用。但是JMagick只用源码包，需要进行编译安装。尽量将ImageMagick和JMagick安装在同一路径下。 Brew install ImageMagick,开始编译JMagick，生成JMagick动态库。 遇到JMagick出现找不到api.h文件(实际上在ImageMagick-7是没有这个api.h文件，在ImageMagick-6是有api.h文件):checking magick/api.h usability… nochecking magick/api.h presence… nochecking for magick/api.h… noconfigure: error: ‘Unable to find ImageMagick header files’。 出现这种情况通过pkg-config、修改configure的参数、查看configure源码，根据报错来修改文件路径，让其能够找到header files等等方法。这些方法都没有解决问题。 该文章找到原因 主要是因为JMagick版本老(最新版本是2013更新的)，无法跟上ImageMagick的节奏。ImageMagick的文件位置都发生了很大的变化。(注.看configure源码，可以看到一些文件路径不在了)。 我们需要做的是：ImageMagick不要安装最新版本，安装旧版ImageMaick6相关版本，并且下载JMagick6.4.0版本。 根据configure的部分源码 123456789101112131415161718192021# Check whether --with-magick-home was given.if test &quot;$&#123;with_magick_home+set&#125;&quot; = set; then withval=$with_magick_home; MAGICK_HOME=$&#123;withval&#125;fifor MPATH in /usr /usr/local /usr/local/ImageMagick /usr/local/ImageMagick-$&#123;VER_MAJOR&#125;.$&#123;VER_MINOR&#125;.$&#123;VER_MICRO&#125; $&#123;MAGICK_HOME&#125; ; do # Location before IM 6.3.8.something if test -f $&#123;MPATH&#125;/include/magick/api.h ; then MAGICK_LIB_PATH=$&#123;MPATH&#125;/lib MAGICK_LIBS=&quot;-L$&#123;MPATH&#125;/lib -lMagick&quot; MAGICK_INCLUDES=-I$&#123;MPATH&#125;/include MAGICK_REALHOME=$&#123;MPATH&#125; fi # Location after IM 6.3.8.something if test -f $&#123;MPATH&#125;/include/ImageMagick/magick/api.h ; then MAGICK_LIB_PATH=$&#123;MPATH&#125;/lib MAGICK_LIBS=&quot;-L$&#123;MPATH&#125;/lib -lMagick&quot; MAGICK_INCLUDES=-I$&#123;MPATH&#125;/include/ImageMagick MAGICK_REALHOME=$&#123;MPATH&#125; fidone 因为编译的该文件的${MPATH}/include/magick/api.h。由于目前include路径下存放的文件多了一层Imagemagick-6，我们要将Imagemagick-6里的所有文件ln -s到include目录下。eg:我的configure命令： JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/&quot; CFLAGS=&quot;-I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/ -I/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/include/darwin&quot; ./configure --with-magick-inc-dir=-I/usr/local/Cellar/imagemagick/6.9.10-14/include/ --with-magick-lib-dir=-L/usr/local/Cellar/imagemagick/6.9.10-14/lib/ ./configure --with-java-home=/usr/libexec/java_home--with-java-includes=/System/Library/Frameworks/JavaVM.framework/Headers --with-magick-inc-dir=/usr/local/Cellar/imagemagick@6/6.9.10-14/include/ --with-magick-lib-dir=/usr/local/Cellar/imagemagick@6/6.9.10-14/lib/ 接下来有些问题下面链接可以解决一部分由Mac OS X 安装JMagick来解决我们configure的问题。因为还有编译文件中的withval=$with_magick_home; MAGICK_HOME=${withval},因此我们可以通过增加 – with_magick_home参数，解决某些问题。 make过程中ERROR ：1234567make[1]: Entering directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src&apos;make[2]: Entering directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src/magick&apos;make[2]: *** No rule to make target `/usr/local/Cellar/imagemagick/6.9.10-14/include/magick/api.h&apos;, needed by `/usr/local/Cellar/jmagick-6.4.0/6.4.0/obj/magick/magick_PixelPacket.lo&apos;. Stop.make[2]: Leaving directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src/magick&apos;make[1]: *** [dir_target] Error 2make[1]: Leaving directory `/usr/local/Cellar/jmagick-6.4.0/6.4.0/src&apos;make: *** [dir_target] Error 2 因为api.h的路径不对，可以通过ln -s 下。eg: cd /usr/local/Cellar/ &amp;&amp; ln -s ./imagemagick\@6/ imagemagick1234567make[1]: Entering directory `/Users/yibo/Downloads/6.4.0/src&apos;make[2]: Entering directory `/Users/yibo/Downloads/6.4.0/src/magick&apos;../../Make.rules:175: *** missing separator. Stop.make[2]: Leaving directory `/Users/yibo/Downloads/6.4.0/src/magick&apos;make[1]: *** [dir_target] Error 2make[1]: Leaving directory `/Users/yibo/Downloads/6.4.0/src&apos;make: *** [dir_target] Error 2 修改Make.rules, 175,176 四个空格换成tab，参见: http://stackoverflow.com/a/15880079/3368344 make make install 成功之后在/usr/local/lib会生成三个文件 jmagick-6.4.0.jar libJMagick-6.4.0.so libJMagick.so -&gt; ./libJMagick-6.4.0.so在动态链接库在不同平台的形式： windows .dll linux .so macos .dylib (最新的动态链接库) .jnilib (以前的动态链接库)需要在mac上使用动态链接库，需要使用dylib的后缀的名称。cp libJMagick.so libJMagick.dylib 测试使用IDEA的单元测试没有问题12345678910try &#123; String property = System.getProperty(&quot;java.library.path&quot;); System.out.println(property); // 输出/usr/local/lib // System.setProperty(&quot;java.library.path&quot;, &quot;/usr/local/lib&quot;); // System.loadLibrary(&quot;JMagick&quot;); System.out.println(&quot;success&quot;); MagickInfo magickInfo = new MagickInfo(&quot;myImage&quot;); &#125; catch (MagickException e) &#123; System.out.println(e); &#125; IDEA的Tomcat需要额外处理：tomcat的VM options增加：-Djmagick.systemclassloader=no -Djava.library.path=/usr/local/lib 参考资料：Mac OS X 安装JMagickMac安装Imagemagick和JMagickLinux的pkg-config命令ImageMagick +Jmagick安装]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phantomjs截图文字不显示]]></title>
    <url>%2F2018%2F12%2F18%2Fphantomjs%E6%88%AA%E5%9B%BE%E6%96%87%E5%AD%97%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[PhantomJS 基于 webkit 内核的无界面浏览器 webkit:webkit tutorial : https://www.paulirish.com/2013/webkit-for-developers/中文了解:https://www.jianshu.com/p/a129b05e2216 学习缘由运营活动需要将用户这一年的数据展示出来，用户是可以截图的。当时方案好几个: 用户自己手动截图，但是一个用户截图效果有可能会不太好，也太麻烦，最无奈的方案。 通过前端来完成给用户截图的功能。（后续被前端废弃。） 服务端对网页进行截图，然后用户直接下载。（推荐使用PhantomJS） 使用过程和了解phantomjs官网下载包分为源码代码包和二进制代码包。 （因为之前不明白centos RPM 包含源码代码包和二进制代码包，碰到了一些麻烦。） phantmjs分平台的软件是二进制包，下载就可以使用。但是值得注意的是mac和linux的平台上，有个细节linux需要依赖fonts。一开始我们没有注意这个问题，才有今天的文章。在mac上截图很正常，但是centos服务器截图就是没有文字。 分析:当时出现在服务器没有显示文字，不明白。 开始怀疑是字体颜色的问题，修改后发现没有效果。 再次认为是JS的原因，通过对请求生成的html进行输出和截图，发现有可能不是html的问题。 最后查阅相关资料，浏览器查找结果有些展示说是字体的问题（因为与字体有关，操作麻烦，直接放弃。想找简单的方法处理），最后没有办法才尝试，字体相关操作。 phantomjs实现服务端屏幕截图这篇博客对linux服务端phantomJS截图的做了很深刻的讲解。但是字体使用是微软雅黑。按照这篇博客讲解操作，我们服务器这边截图的字体样式有点难看，太纤细了。 因此将字体变得好看成为重中之重。 查询当前MAC浏览器的字体是什么类型？？ (WhatFont)查询字体 结果：PingFang SC 前端指定字体样式:font-family {} 没有效果 前端@font-face 下载字体 考虑网速的问题，需要压缩字体。没有执行 服务端寻找字体，放到服务器使用。 {最终解决方案} 首选字体PingFang SC phantomjs在linux下截图中文字体问题给我们很好的思路，尝试拷贝字体。 直接mac 命令行拷贝 没有权限失败。 通过mac 命令行 (open /) 打开系统文件，进行/System/Library/Fonts的PingFang.ttc 拖拽拷贝成功。 需要将PingFang.ttc的格式转换为linux可用ttf格式。上面博客推荐的转换地址发现，超过了上传文件最大限度。 Convert Font Files 这个网址转换成功。 但是新的问题：浏览器上使用的是PingFang SC字体。linux服务器使用的PingFang字体，导致看到和截图字体样式不一致。 linux 建立字体索引 更新缓存123mkfontscalemkfontdirfc-cache 附赠代码123456789101112131415161718192021&gt; renderImage.js phantomJS 的执行js代码&quot;use strict&quot;;var page = require(&apos;webpage&apos;).create();var system = require(&apos;system&apos;), pageWidth, pageHeight, pageUrl, format, quality, imagePath;if (system.args.length != 7) &#123; console.log(&apos;Usage: renderImage.js &lt;pageWidth pageHeight pageUrl format quality imagePath&gt;&apos;); phantom.exit(1);&#125; else &#123; pageWidth = system.args[1] pageHeight = system.args[2]; pageUrl = system.args[3]; format = system.args[4]; quality = system.args[5]; imagePath = system.args[6];&#125;page.viewportSize = &#123; width: pageWidth, height: pageHeight &#125;;page.open(pageUrl, function start(status) &#123; page.render(imagePath, &#123;format: format, quality: quality&#125;); phantom.exit();&#125;); 123456789101112131415161718192021222324252627&gt; java 执行phantomJS的代码 /** * 将网页渲染成图片 * format 图片格式 quality 图片质量（0~100） * pageWidth 网页宽度 pageHeight 网页高度 */ public static void renderImage(String phantomJSPath, String renderImageJSPath, int pageWidth, int pageHeight, String renderUrl, String format, int quality, String outPutImagePath) &#123; // 执行命令参数 List&lt;String&gt; params = Arrays.asList(phantomJSPath, renderImageJSPath, pageWidth + &quot;&quot;, pageHeight + &quot;&quot;, renderUrl, format, quality + &quot;&quot;, outPutImagePath); ProcessBuilder processBuilder = new ProcessBuilder() .command(params); try &#123; processBuilder.redirectError(); Process process = processBuilder.start(); InputStream processIS = process.getInputStream(); String output = IOUtils.toString(processIS); logger.info(&quot;渲染成图片: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), output); IOUtils.closeQuietly(processIS); int result = process.waitFor(); if (result != 0) &#123; logger.warn(&quot;执行失败: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), output); &#125; &#125; catch (InterruptedException | IOException e) &#123; logger.warn(&quot;执行失败: &#123;&#125; -&gt; &#123;&#125;&quot;, processBuilder.command(), e); &#125; &#125; 参考资料：phantomjs实现服务端屏幕截图phantomjs在linux下截图中文字体问题phantmjs下载地址PingFang sc字体的使用phantomJS API]]></content>
      <tags>
        <tag>phantomjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PERL学习]]></title>
    <url>%2F2018%2F12%2F05%2FPERL%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[perl 是脚本语言，在工作部署、编译等一些关于linux服务器上的事情都会跟perl打交道。写下自己学习路程，给自己日后总结。 文档查询perldoc -f xxxx perl数据类型字符串定义字符串变量: my $name (my: 定义变量 $: 表示字符串 name: 变量名)注意点 内插型字符串 其他变量的数据可以在插入字符串中展示 12my $name = &quot;Inigo MOntoya&quot;;print &quot;My name is $name&quot;; 非内插型字符串 无论什么字符都直接展示 1print &apos;You may have won $1,000,000&apos;; 转义字符 有些特殊字符需要转义才能正输出 12345my $email = &quot;andy@foo.com&quot;;print $email;# Prints &quot;andy.com&quot;解决方案:my $email = &quot;andy\@foo.com&quot;; 字符串操作函数 length() 获取字符串长度 subStr() 能够截取字符串 数组 创建 访问 $stooges[1] 数组长度 @stooges scalar @stooges 数组特性 数组没有边界 数组合并会平展元素 数组操作方法 shift 从数组开头移除元素 unshift 将元素添加到数组开头 push 将元素添加到数组的结尾 pop 从数组的结尾移除元素 数组高级用法 提取数组的部分元素 12my @a = &apos;a&apos;..&apos;z&apos;;my @vowels = @a[0, 4, 8, 14, 20]; 分配数组块 使用splice 12345678使用场景 数组拼接my @a = qw(Steve Stu Stan);$a[1] = [&apos;Stewart&apos;, &apos;Zane&apos;];# @a = (&apos;Steve&apos;, ARRAY(0x841214c), &apos;Stan&apos;)my @a = qw(Steve Stu Stan);splice @a 1, 1, &apos;Stewart&apos;, &apos;Zane&apos;;#@a = (&apos;Steve&apos;, &apos;Stewart&apos;, &apos;Zane&apos;, &apos;Stan&apos;) 利用map处理数组 (map 本质上是返回列表的foreach 循环)map 123my @ARRAY = (1, 2, 3, 4, 5);my %hash = map &#123;$_ =&gt; $_ * 9&#125; @ARRAY;# %hash = (1 =&gt; 9, 2 =&gt; 18, 3 =&gt; 27, 4 =&gt; 36, 5 =&gt; 45) grep从数组中选择项目 (grep 本质上返回列表foreach循环)123my @ARRAY = (1, 2, 3, 4, 5);my @NEWARRAY = grep &#123;$_ * 9&#125; @ARRAY&#123;&#125; 包含表达式的意思 哈希哈希就是键值对 创建 123456789101.方法一my %stooges = ( &apos;Moe&apos;, &apos;Howard&apos;, &apos;Larry&apos;, &apos;Fine&apos;, );2. 方法二my %stooges = ( Moe =&gt; &apos;Howard&apos;, Larry =&gt; &apos;Fine&apos;, ) 哈希转数组 12my @hash_array = %stooges;# Contains (&apos;Moe&apos;, &apos;Howard&apos;, &apos;Larry&apos;, &apos;Fine&apos;); 使用{}操作哈希输出哈希值 更改哈希值 删除哈希条目 123456print $stooges&#123;&apos;Moe&apos;&#125;;#Prints &quot;Howard&quot;;$stooges&#123;&apos;Moe&apos;&#125; = &apos;NiHao&apos;;delete $stooges&#123;&apos;Moe&apos;&#125;;unlink $stooges&#123;&apos;Moe&apos;&#125;;delete 不会删除文件 unlink 为删除文件 哈希的键/值数组 12my @key = keys %stooges;my @value = values %stooges; 哈希特点 哈希是无序的 无法排序 哈希define exist的差异]]></content>
      <tags>
        <tag>perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（经典讲解）]]></title>
    <url>%2F2018%2F10%2F21%2Fregular-expression%2F</url>
    <content type="text"><![CDATA[正则表达式 regular expression（经典讲解） 说明：所谓经典讲解，是作者个人直观感觉。个人以前看过大量“正则表达式”的博客文章，但是始终未能深刻理解正则表达式。但是最近一篇有关linux的书籍（开源旅行手册）提到正则表达式，让我醍醐灌顶。 说明：本文内容主要来自《OS WORLD TRIP》又名《开源世界旅行手册》,由Kardinal著。该书的源地址：下载地址 。正则表达式的内容在部分2:地理的第26章 讲解正则表达式简介&emsp;&emsp;对于文本内容的处理，通常使用交互方式，手工调整;但如果你对源文本比较了解，则可以采用自动化的批量处理方式，这种方式效率高、迅速快批量处理，要求根据一定规则，匹配源文本中的字符，转换为目标文本，这就要用到正则表达式。最简单的例子，使用 regular 进行匹配，结果如下:1`regular` expression 正则表达式有许多变种:glob 表达式、基本正则表达式、perl 正则表达式、emacs 正则表达式…… 运算优先级&emsp;&emsp;正则表达式与数学表达式的不同在于，数学表达式执行数学运算，而正则表达式执行字符运算;相同的是，它们都按一定的优先级进行运算 运算符 操作 \ 转义符 () 捕获、匹配、断言 [] 字符类 *+? 限定符 {} 范围 ^$ 位置和顺序 &#124; 或 转义符&emsp;&emsp;如果源文本中出现了正则表达式中的运算符，如 ( ，使用 ( 无法匹配下列文本中的括弧，这时要使用 \ 进行转义。用 \( 匹配。在 Emacs 和 Vim 正则表达式中正好反过来，使用 \( 表示分组，用 ( 匹配字符。1`(`regular expression) &emsp;&emsp;在文本中匹配“运算优先级”一节中的所有运算符,都要用这种形式:12\运算符如 \* \+ \- \\的使用 在文本中匹配 \ 本身，要用 \\。非运算符前使用 \，则有特殊的意义，例如 \n 匹配一个换行符。常用转义字符: 常规匹配 转义字符 涵义 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束，在字符类里代表退格 ^ 匹配字符串的开始，在字符类里表 示”非“ $ 匹配字符串的结束 [aeiou] 字符集合,匹配所包含的任意一个字符 反向匹配 转义字符 涵义 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^aeiou] 匹配除了aeiou 这几个字母以外的任意字符 特殊字符 转义字符 涵义 \a 报警字符(打印它的效果是电脑嘀一 声) \t 制表符，Tab \r 回车 \v 垂直制表符 \f 换页符 \n 换行符 \e Escape \0nn ASCII 代码中八进制代码为 nn 的字符 \xnn ASCII 代码中十六进制代码为 nn 的字符 \unnnn Unicode 代码中十六进制代码为 nnnn 的字符 \cN ASCII 控制字符。比如 \cC 代表 Ctrl+C \A 字符串开头(类似^，但不受处理多行 选项的影响) \Z 字符串结尾或行尾(不受处理多行选 项的影响) \z 字符串结尾(类似$，但不受处理多行 选项的影响) \G 当前搜索的开头 字符类&emsp;&emsp;要想匹配数字、字母、空白很容易，因为已经有了对应这些字符集合的转义符，但是如果你 想匹配没有预定义的字符集合(比如元音字母 a、e、i、o、u)，应该怎么办?&emsp;&emsp;正则表达式中允许你自定义字符类，在方括号里列出它们就可以了1[aeiou] &emsp;&emsp;预定义的字符集合，也可以用字符类表示，如 \d 等价于 [0-9] 有些运算符，在字符类中使用会有另一种意义，例如 ^ 表示“字符串开始”，但在字符类中却表示 “非”，以 expression 为例，使用 [exp] 匹配:1`exp`r`e`ssion 使用 [^exp] 匹配(字符串中非 e、x、p 的字符):1exp`r`e`ssion` 而使用 ^[exp] 匹配(以 e、x 或 p 起始的字符串):1`e`xpression 限定符&emsp;&emsp;在上一小节中的表格中，我们知道. 可以匹配除换行符以外的任意字符，使用. 匹配下列 文本:1expression 但是 . 每次只匹配一个字符，如果想一次匹配多个，则要使用限定符。 贪婪限定符 惰性限定符 作用 * *? 匹配零次或多次 + +? 匹配一次或多次 ? ?? 匹配零次或一次 {3} {3}? 匹配三次 {3,5} {3,5}? 匹配三到五次 {3,} {3,}? 匹配三次或以上 下面通过实例了解限定符的区别。 es 的匹配结果1expr`es`sion es+ 的匹配结果(e，一个或多个 s)1expr`ess`ion es* 的匹配结果(e，零或多个 s)1`e`xpr`ess`ion es? 的匹配结果(e，零或一个 s)1`e`xpr`es`sion 贪婪与懒惰&emsp;&emsp;使用限定符进行匹配时，默认匹配尽可能多的字符。无论用 .* 还是 .+匹配下列文本，都会匹配全部1`expression` 这种方式称为“贪婪模式”。在限定符之后加 ? 则匹配尽可能少的字符，称为“懒惰模式”。 (懒惰模式的详解：.+ 匹配一个或多个任意字符，在贪婪模式中，它匹配尽可能多的字符;而懒惰模式中(.+?)，则只匹配一个字符; .{3,5} 在贪婪模式中尽可能匹配5个字符，在懒惰模 式中(.{3,5}?)只匹配3个字符; ?和 * 这样可以匹配零次的限定符，在懒惰模式下不匹配任何字符( .*?、.?? ))。例如，使用贪婪模式 a.+b 匹配:1`aaabab` 使用懒惰模式 a.+?b 匹配:1`aaab`ab 分支条件| 表示“或”，使用它进行分支选择:例如 [a-z]+|\d+ 匹配单词或数字:1expression 123 分组、捕获、不捕获分组&emsp;&emsp;使用(表达式)对表达式进行分组，即用小括号来指定子表达式叫做分组。例如使用 (\d{3}\.){2} 匹配下面例子中的数字:1abc`123.456.`def \d{3} 表示三个数字， (\d{3}\.) 表示三个数字加“ . ”为一组，{2} 表示这一组内容重复两次 捕获&emsp;&emsp;在对表达式进行分组的时候，会捕获文本到自动命名的组里。可以使用 \1 \2 ...... 来反向引用组。例如用 ([a-z]*)\s(\d*) 匹配下列文本， ([a-z]*) 为 \1 组， (\d*) 为 \2 组1`kardinal 1234567` 使用 \2\s\1 替换 ([a-z]*)\s(\d*) ，可以改变两个字符串的顺序11234567 kardinal 使用([a-z]*)\s(\d*)\1匹配下列文本，([a-z]*) 为 \1 组， (\d*) 为 \2组，([a-z]*)\s(\d*)\1中\1是反向引用组:1`kardinal 1234567kardinal` 如果分组较多，计数可能会不太方便，可以给分组指定名称，例如:12(?&lt;name&gt;[a-z]*)\s(?&lt;num&gt;\d*) name、num 是分组的名称\k&lt;num&gt;\s\k&lt;name&gt; (?#使用“`\k&lt;name&gt;`”反向引用) 使用 (?:表达式) ，则只是分组，而不捕获，下面例子中， (\d*) 为 \1 组1(?:[a-z]*)\s(\d*) 不捕获的典型应用：用使用在或的应用中，使用或需要使用括号即捕获组，但是又不想存在捕获组，则可以使用不捕获。1l(?:i|o|e)ve 注明：反向引用提供了标识字符串中的重复字符或子字符串的方便途径。 例如，如果输入字符串包含某任意子字符串的多个匹配项，可以使用捕获组匹配第一个出现的子字符串，然后使用反向引用匹配后面出现的子字符串。捕获文本放入对应的分组是需要消耗内存的。如何后续不反向引用分组，可以采用捕获但是不分组。 零宽断言&emsp;&emsp;目前为止，我们学到的正则表达式匹配，都是有“宽度”的，使用 \w+。 匹配下面文本，会将 。 一同匹配:12regular。expression。 如果不想匹配符号，只匹配一个位置，就要用到“零宽断言”(匹配宽度为零，满足一定的条件的断言)，零宽断言使用 (?=表达式) 的语法，例如 \w+(?=。) ，其中 (?=。) 表示。 前面的位置(先行断言)。12`regular`。`expression`。 高级应用(关于为什么叫零宽断言)：表达式写法：\w+(?=。)。\w+ | \w+(?=。)\w+1`regular。zero` 如果需要匹配后面的位置，如:12。`regular`。`expression` 则要用到后发断言 (?&lt;=。) ，使用 (?&lt;=。)\w+ 得到上面的匹配结果使用 (?&lt;=&lt;b&gt;).*(?=&lt;/b&gt;) 匹配标签中的内容1&lt;b&gt;`粗体`&lt;/b&gt; 负向零宽断言&emsp;&emsp;负向零宽断言 (?!表达式) 也是匹配一个零宽度的位置，不过这个位置的“断言”取表达式的反值，例如 (?!表达式) 表示 表达式 前面的位置，如果 表达式 不成立，匹配这个位置;如果 表达式 成立，则不匹配:1234`expression`expression。`expression`，`expression`; 以上为使用 .+n(?!。) 的匹配结果。注意与 .+n[^。] 匹配的区别1234expression`expression，``expression;`expression。 同样，负向零宽断言也有“先行”和“后发”两种，负向零宽后发断言为 (?&lt;!表达式) 使用 (?&lt;![&lt;/])para(?!&gt;) 匹配下面文本:1&lt;para&gt;`para`表示一个段落&lt;/para&gt; (?&lt;![&lt;/]) 表示 para 左边不能为 &lt; 或 / ; (?!&gt;) 表示 para 右边不能为 &gt;。 常用分组语法 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 推荐其他网址正则表达式全集正则表达式简明参考 (重点在分组和反向引用)正则表达式30分钟教程 (常用分组语法的总结)正则表达式的先行断言(lookahead)和后行断言(lookbehind)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS内网测试和外网更新]]></title>
    <url>%2F2018%2F10%2F08%2FCORS%E5%86%85%E7%BD%91%E6%B5%8B%E8%AF%95%E5%92%8C%E5%A4%96%E7%BD%91%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[解释CORS的定义CORS （Cross-origin resource sharing）跨域资源共享问题，是W3C的标准。 当某一资源在自己的资源服务器上的不同域或者端口请求另一个资源时，那么该资源会发起一次跨域请求. (Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional HTTP headers to tell a browser to let a web application running at one origin (domain) have permission to access selected resources from a server at a different origin. A web application makes a cross-origin HTTP request when it requests a resource that has a different origin (domain, protocol, and port) than its own origin.) 个人理解：我（浏览器）在小明家（服务器）的正门（端口）借东西（资源）。突然还需要其他东西，但是不是小明给我，或者不是正门给我是在侧门给我，那我怎么能够相信这个东西有没有毒啊，有没有进过其他人的手。对于这种情况呢，我就给一个信物（Origin）给小明（服务器），只有小明（服务器）知道信物交换的秘密，正确的情况会把信物翻版（Access-Control-Allow-Origin）给我，不正确就直接不要。 哪些情况会出现CORS的问题我遇到的HTTPS在CHROME浏览器出现跨域字体无法显示,在safari和HTTP的情况没有出现。详细介绍哪些情况会出现跨域的情况列链接并前端的角度该如何解决问题。 解决方案对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是由浏览器自动在头信息中增加一个 Origin 字段。然后只需要在返回的相应上加上Access-Control-Allow-Origin:[Origin]|* 。前端详细介绍了解 接下来详细讲实际解决的情况 需要让内网出现线上的情况 按照网上解决方案去解决 线上CDN资源需要让其失效 内网配置出线上环境我们内网是http协议，不支持https的协议，没有出现线上的情况。 先需要将线上的证书下载到本地，在上传到内网指定位置。 先将内网的nginx的配置文本上加上https的443的端口访问处理。(/opt/nginx/conf/conf.d) 证书和域名是一一对应，所有配置文件的server-name 为证书上的域名。 server { listen 443; server_name #证书上的域名即线上的网址 access_log #日志地址 ssl on; ssl_certificate #证书地址 ssl_certificate_key #证书地址 location ~ / { proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_set_header X-Real-IP $remote_addr; proxy_set_header FORWARDED-FOR $remote_addr; proxy_pass #代理到Tomcat的服务器的域名+端口 include conf.d/proxy_params;}} 1.遇到问题只能通过线上域名访问，但是无法访问到内网的资源。2.DNS 服务详细了解 先了解客户端进行域名解析的流程：先查hosts文件若没有，查本地DNS缓存若没有，再查DNS服务器：先查DNS服务器的本地DNS缓存若没有，再查DNS服务器的解析库都没有，那DNS向根域发起请求，开始迭代查询如果缓存的有效期为1天的话，能极大减轻DNS服务器的压力，所以对于DNS的架构，“缓存”是很重要的。 3.在/etc/hosts文件加上ip和域名的强制映射(内网ip（nginx） 线上域名）。我们的nginx和tomcat服务器是在同一个服务器上。 接下来线上域名的访问都会转接到内网资源的访问。（另一个办法：通过Charles进行代理实现）4.详细分析后，字体是加载进来的js代码发起的静态资源访问（CORS的访问，二级域名不一样）。折腾好久才想起来的，但是静态资源的访问是通过不同内外网环境进行变化的，内网静态资源都在内网服务器上，外网的静态资源在CDN缓存上和静态资源服务器上。5.将加载js的代码写死，变成直接访问外网的静态资源。（与线上保持一致）6.静态资源访问需要变成内网资源的访问。同样，先在hosts文件加上ip和静态资源的域名的强制映射（内网ip 线上域名）。内网静态资源nginx配置 server { listen 443; server_name #静态资源服务器 gzip on; ssl on; ssl_certificate /data/config/ssl/star.enjoymeet.com.chained; ssl_certificate_key #证书地址 access_log #证书地址 location ~* \.(eot|ttf|woff|woff2)$ { add_header Access-Control-Allow-Origin * ; add_header Access-Control-Allow-Methods GET; proxy_pass #代理到Tomcat的服务器的域名+端口 } } 基本上实现在内网测试。参考资料：在nginx上解决问题Nginx通过CORS实现跨域1Nginx通過CORS實現跨域2HTTP访问控制（CORS） How do I add Access-Control-Allow-Origin in NGINX? 线上处理 CDN 回源，我们回源的访问80端口欧，HTTP协议。 CDN的资源让线上的资源失效。]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义程序朗读单词文本]]></title>
    <url>%2F2018%2F10%2F06%2FspeackEnglishWord%2F</url>
    <content type="text"><![CDATA[自定义程序朗读单词文本意思其核心内容是围绕Mac Terminal终端say命令展开的让学习英语就像听歌一样简单 具体步骤：第一步 简单使用say去读一小段的文本 say Hello World; 学习使用say去读文件 say -f …/…/hello_world.txt|.csv 详细使用可以输入命令 man say 第二步 寻找合适单词翻译网站 通过复制粘贴的形式到文件中 目前我使用的是扇贝网站的单词学习 第三步 编写自己的程序 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/perluse strict;use warnings;use Time::HiRes qw(usleep nanosleep);# 获取文件参数my $file = $ARGV[0] or die &quot;Need to get CSV file on the command line\n&quot;;# 打开文件open(my $data, &apos;&lt;&apos;, $file) or die &quot;Could not open &apos;$file&apos; $!\n&quot;;# 一行一行的读文件while (my $line = &lt;$data&gt;) &#123; usleep(500); # 去除回车键 chomp $line; # 一行文本按照空格符的进行分割成组 my @strWord = split(/[\s+]/, $line); foreach(@strWord)&#123; if($_ !~ /\./)&#123; `say &quot;$_&quot;`; if($_ =~ /\w+/)&#123; my $size = length($_); my $strIndex = 0; my $strEnd = $strIndex + 1; while($strIndex &lt; $size)&#123; my $subWord = substr($_, $strIndex, 1); `say &quot;$subWord&quot;`; $strIndex = $strIndex + 1; &#125; usleep(500); # say 单词和单词的释义 `say &quot;$_&quot;`; &#125; print &quot;$_ &quot;; &#125; &#125; print &quot;\n&quot;;&#125; 通过perl命令执行程序 eg: perl readCSV.pl /Users/useheart/学习资料/英语单词学习.csv]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
